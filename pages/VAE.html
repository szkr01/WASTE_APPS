<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VAE Gradient Canvas - Latent Space Explorer</title>
    <meta name="description" content="An interactive VAE application to generate MNIST-like digits by exploring a 2D latent space. Built with ONNX.js and styled with a vibrant gradient theme.">
    <meta name="page:icon" content="fas fa-project-diagram">
    <meta name="page:color" content="#8b5cf6">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        @keyframes subtle-glow {
            0% {
                box-shadow: 0 0 15px -5px rgba(139, 92, 246, 0.3), 0 0 30px -15px rgba(139, 92, 246, 0.2);
            }
            50% {
                box-shadow: 0 0 15px -5px rgba(139, 92, 246, 0.5), 0 0 30px -15px rgba(139, 92, 246, 0.4);
            }
            100% {
                box-shadow: 0 0 15px -5px rgba(139, 92, 246, 0.3), 0 0 30px -15px rgba(139, 92, 246, 0.2);
            }
        }
        
        #outputCanvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .gradient-text {
            background-image: linear-gradient(to right, #67e8f9, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #a78bfa;
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #1e1b4b;
            box-shadow: 0 0 10px rgba(167, 139, 250, 0.7);
            transition: all 0.2s ease-in-out;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #a78bfa;
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid #1e1b4b;
            box-shadow: 0 0 10px rgba(167, 139, 250, 0.7);
        }

        input[type="range"]:hover::-webkit-slider-thumb {
             background: #c4b5fd;
        }
        input[type="range"]:focus::-webkit-slider-thumb {
            box-shadow: 0 0 0 3px #1e1b4b, 0 0 0 6px #8b5cf6;
        }
    </style>
</head>

<body class="bg-gradient-to-br from-slate-900 via-indigo-950 to-black text-slate-200 antialiased overflow-hidden h-screen">

    <div id="loadingMessage" class="fixed inset-0 bg-slate-900/80 backdrop-blur-sm flex items-center justify-center z-50 transition-opacity duration-300">
        <div class="text-center">
            <svg class="animate-spin h-12 w-12 text-violet-400 mx-auto mb-6" xmlns="http://www.w.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="text-xl font-semibold text-slate-100">VAEモデルを読み込み中...</p>
            <p class="text-sm text-slate-400 mt-2">素晴らしい数字が生成されるまで、もうしばらくお待ちください！</p>
        </div>
    </div>

    <div id="errorMessageContainer" class="fixed bottom-4 right-4 z-50 transition-all duration-300 opacity-0 translate-y-2">
        <div class="bg-gradient-to-r from-red-500 to-orange-500 text-white px-6 py-4 rounded-lg shadow-lg flex items-start">
            <svg class="h-6 w-6 mr-3 flex-shrink-0" xmlns="http://www.w.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" />
            </svg>
            <div>
                <strong class="font-bold">エラーが発生しました</strong>
                <span class="block text-sm opacity-90" id="errorMessageText"></span>
            </div>
            <button class="ml-4 -mr-2 -mt-2 p-2 rounded-full hover:bg-white/20 transition-colors" onclick="document.getElementById('errorMessageContainer').classList.add('opacity-0', 'translate-y-2'); document.getElementById('errorMessageContainer').classList.remove('opacity-100', 'translate-y-0');">
                <svg class="h-5 w-5" xmlns="http://www.w.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>

    <div class="container mx-auto max-w-6xl h-screen flex flex-col py-6 px-4 sm:px-6 lg:px-8">
        <header class="text-center mb-6 shrink-0">
            <h1 class="text-4xl sm:text-5xl font-bold tracking-tighter">
                <span class="gradient-text">VAE Gradient Canvas</span>
            </h1>
            <p class="mt-3 text-lg text-slate-400 max-w-2xl mx-auto">
                XYパッドを操作して潜在変数を調整し、手書き数字画像をリアルタイムで生成しましょう。
            </p>
        </header>

        <main class="flex-grow grid grid-cols-1 lg:grid-cols-2 gap-8 items-stretch min-h-0">
            <div class="glass-card rounded-2xl p-6 sm:p-8 flex flex-col">
                <h2 class="text-2xl font-semibold text-slate-100 mb-2 flex items-center">
                    <i class="fas fa-project-diagram mr-3 text-violet-400"></i>
                    XY Pad (潜在空間)
                </h2>
                <p class="text-sm text-slate-400 mb-4 shrink-0">クリックまたはドラッグで操作します。</p>
                <div class="flex-grow flex items-center justify-center">
                     <canvas id="xyPad" width="300" height="300" class="rounded-lg border border-slate-700 cursor-crosshair transition-all duration-300 ease-in-out hover:border-violet-500 focus:outline-none focus:ring-2 focus:ring-violet-500 focus:ring-offset-2 focus:ring-offset-slate-900" style="animation: subtle-glow 5s infinite ease-in-out;"></canvas>
                </div>
                <div class="mt-4 text-center font-mono text-sm tracking-wider shrink-0">
                    <span class="text-slate-400">X:</span> <span id="xCoord" class="text-cyan-300 font-semibold">-</span>,
                    <span class="text-slate-400">Y:</span> <span id="yCoord" class="text-cyan-300 font-semibold">-</span>
                </div>
            </div>

            <div class="glass-card rounded-2xl p-6 sm:p-8 flex flex-col">
                <h2 class="text-2xl font-semibold text-slate-100 mb-2 flex items-center">
                    <i class="fas fa-image mr-3 text-violet-400"></i>
                    生成された画像
                </h2>
                <p class="text-sm text-slate-400 mb-4 shrink-0">潜在変数から生成されたMNIST風の数字です。</p>
                <div class="flex-grow flex items-center justify-center">
                    <canvas id="outputCanvas" width="280" height="280" class="rounded-lg border border-slate-700 bg-black"></canvas>
                </div>
                
                <div class="controls mt-6 space-y-5 shrink-0">
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <label for="xSlider" class="text-sm font-medium text-slate-300">潜在変数 X</label>
                            <span id="xSliderValue" class="text-sm font-mono text-cyan-300 font-semibold">0.00</span>
                        </div>
                        <input type="range" id="xSlider" min="-3" max="3" value="0" step="0.05">
                    </div>
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <label for="ySlider" class="text-sm font-medium text-slate-300">潜在変数 Y</label>
                            <span id="ySliderValue" class="text-sm font-mono text-cyan-300 font-semibold">0.00</span>
                        </div>
                        <input type="range" id="ySlider" min="-3" max="3" value="0" step="0.05">
                    </div>
                    <button id="resetButton" class="w-full px-6 py-3 bg-gradient-to-r from-violet-600 to-indigo-600 text-white text-sm font-semibold rounded-lg hover:from-violet-500 hover:to-indigo-500 focus:outline-none focus:ring-2 focus:ring-offset-4 focus:ring-offset-slate-900 focus:ring-violet-500 transition-all duration-200 ease-in-out shadow-lg shadow-indigo-600/20 hover:shadow-xl hover:shadow-indigo-500/30 transform hover:-translate-y-0.5">
                        中央にリセット (0, 0)
                    </button>
                </div>
            </div>
        </main>
        
        <footer class="text-center mt-6 pt-4 border-t border-slate-800 shrink-0">
            <p class="text-sm text-slate-500">
                ONNX Runtime Web を使用した VAE デコーダーデモ。
            </p>
        </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script>
        const xyPad = document.getElementById('xyPad');
        const outputCanvas = document.getElementById('outputCanvas');
        const xCoordDisplay = document.getElementById('xCoord');
        const yCoordDisplay = document.getElementById('yCoord');
        const xSlider = document.getElementById('xSlider');
        const ySlider = document.getElementById('ySlider');
        const xSliderValue = document.getElementById('xSliderValue');
        const ySliderValue = document.getElementById('ySliderValue');
        const resetButton = document.getElementById('resetButton');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorMessageContainer = document.getElementById('errorMessageContainer');
        const errorMessageText = document.getElementById('errorMessageText');

        const xyPadCtx = xyPad.getContext('2d');
        const outputCtx = outputCanvas.getContext('2d');

        const padSize = xyPad.width;
        const imgSize = 28;
        const outputDisplaySize = outputCanvas.width;
        
        const latentMin = -3.0;
        const latentMax = 3.0;
        const latentRange = latentMax - latentMin;

        let ortSession;
        let currentLatentX = 0;
        let currentLatentY = 0;
        let isDragging = false;
        let animationFrameId = null;

        function showLoading(show) {
            loadingMessage.style.display = show ? 'flex' : 'none';
            loadingMessage.classList.toggle('opacity-100', show);
            loadingMessage.classList.toggle('opacity-0', !show);
        }
        
        function showError(message) {
            errorMessageText.textContent = message;
            errorMessageContainer.classList.remove('opacity-0', 'translate-y-2');
            errorMessageContainer.classList.add('opacity-100', 'translate-y-0');
            setTimeout(() => {
                 errorMessageContainer.classList.add('opacity-0', 'translate-y-2');
                 errorMessageContainer.classList.remove('opacity-100', 'translate-y-0');
            }, 5000);
        }

        async function loadModel() {
            showLoading(true);
            try {
                ortSession = await ort.InferenceSession.create('../Assets/vae_decoder.onnx');
                await updateFromSliders();
            } catch (e) {
                console.error("Failed to load ONNX model:", e);
                showError("モデルのロードに失敗しました。ファイルパス(Assets/vae_decoder.onnx)を確認してください。");
            } finally {
                showLoading(false);
            }
        }

        function updateSliderValueDisplays(x, y) {
            xSliderValue.textContent = x.toFixed(2);
            ySliderValue.textContent = y.toFixed(2);
        }
        
        function scheduleGenerateImage(latentX, latentY) {
            currentLatentX = parseFloat(latentX.toFixed(4));
            currentLatentY = parseFloat(latentY.toFixed(4));
        
            xCoordDisplay.textContent = currentLatentX.toFixed(2);
            yCoordDisplay.textContent = currentLatentY.toFixed(2);
            
            xSlider.value = currentLatentX;
            ySlider.value = currentLatentY;
            updateSliderValueDisplays(currentLatentX, currentLatentY);
            
            drawXYPad();

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            animationFrameId = requestAnimationFrame(async () => {
                if (!ortSession) {
                    console.warn("ONNX session not ready.");
                    showError("ONNXセッションの準備ができていません。");
                    return;
                }

                const latentInput = new ort.Tensor('float32', [currentLatentX, currentLatentY], [1, 2]);
                const feeds = { 'latent_input': latentInput };

                try {
                    const results = await ortSession.run(feeds);
                    const outputTensor = results.image_output;
                    const imageData = outputTensor.data;
                    drawOutput(imageData);
                } catch (e) {
                    console.error("Error during inference:", e);
                    showError("推論中にエラーが発生しました。");
                }
            });
        }


        function drawXYPad() {
            xyPadCtx.clearRect(0, 0, padSize, padSize);
            
            xyPadCtx.strokeStyle = 'rgba(100, 116, 139, 0.3)';
            xyPadCtx.lineWidth = 1;
            xyPadCtx.beginPath();
            xyPadCtx.moveTo(padSize / 2, 0);
            xyPadCtx.lineTo(padSize / 2, padSize);
            xyPadCtx.moveTo(0, padSize / 2);
            xyPadCtx.lineTo(padSize, padSize / 2);
            xyPadCtx.stroke();

            const displayX = ((currentLatentX - latentMin) / latentRange) * padSize;
            const displayY = ((latentMax - currentLatentY) / latentRange) * padSize;

            const gradient = xyPadCtx.createRadialGradient(displayX, displayY, 0, displayX, displayY, 10);
            gradient.addColorStop(0, '#c4b5fd');
            gradient.addColorStop(1, '#8b5cf6');

            xyPadCtx.fillStyle = gradient;
            xyPadCtx.beginPath();
            xyPadCtx.arc(displayX, displayY, 8, 0, 2 * Math.PI);
            xyPadCtx.fill();
            
            xyPadCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            xyPadCtx.lineWidth = 2;
            xyPadCtx.stroke();
        }

        function drawOutput(pixelData) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = imgSize;
            tempCanvas.height = imgSize;
            const tempCtx = tempCanvas.getContext('2d');
            const canvasImageData = tempCtx.createImageData(imgSize, imgSize);

            for (let i = 0; i < imgSize * imgSize; i++) {
                const pixelValue = Math.max(0, Math.min(255, Math.floor(pixelData[i] * 255)));
                canvasImageData.data[i * 4 + 0] = pixelValue;
                canvasImageData.data[i * 4 + 1] = pixelValue;
                canvasImageData.data[i * 4 + 2] = pixelValue;
                canvasImageData.data[i * 4 + 3] = 255;
            }
            tempCtx.putImageData(canvasImageData, 0, 0);

            outputCtx.imageSmoothingEnabled = false;
            outputCtx.clearRect(0, 0, outputDisplaySize, outputDisplaySize);
            outputCtx.drawImage(tempCanvas, 0, 0, imgSize, imgSize, 0, 0, outputDisplaySize, outputDisplaySize);
        }

        function handlePadInteraction(event) {
            event.preventDefault();
            const rect = xyPad.getBoundingClientRect();
            let clientX = event.clientX;
            let clientY = event.clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            }
            
            let x = clientX - rect.left;
            let y = clientY - rect.top;

            x = Math.max(0, Math.min(padSize, x));
            y = Math.max(0, Math.min(padSize, y));

            const latentX = (x / padSize) * latentRange + latentMin;
            const latentY = ((padSize - y) / padSize) * latentRange + latentMin;

            scheduleGenerateImage(latentX, latentY);
        }

        xyPad.addEventListener('mousedown', (e) => { isDragging = true; handlePadInteraction(e); });
        xyPad.addEventListener('mousemove', (e) => { if (isDragging) { handlePadInteraction(e); } });
        document.addEventListener('mouseup', () => { isDragging = false; });
        
        xyPad.addEventListener('touchstart', (e) => { isDragging = true; handlePadInteraction(e); }, { passive: false });
        xyPad.addEventListener('touchmove', (e) => { if (isDragging) { handlePadInteraction(e); } }, { passive: false });
        document.addEventListener('touchend', () => { isDragging = false; });

        async function updateFromSliders() {
            const latentX = parseFloat(xSlider.value);
            const latentY = parseFloat(ySlider.value);
            scheduleGenerateImage(latentX, latentY);
        }

        xSlider.addEventListener('input', updateFromSliders);
        ySlider.addEventListener('input', updateFromSliders);

        resetButton.addEventListener('click', () => {
            scheduleGenerateImage(0, 0);
        });

        loadModel();
        drawXYPad();
        updateSliderValueDisplays(currentLatentX, currentLatentY);
    </script>
</body>
</html>