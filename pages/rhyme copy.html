<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Rhyme Finder | 意味で絞り込む押韻検索</title>
    <meta name="description" content="An advanced Japanese rhyme finder that allows you to semantically search and re-rank results using AI embeddings. Find the perfect rhyming word based on meaning and context. Powered by Transformers.js.">
    <meta name="page:icon" content="fas fa-wave-square">
    <meta name="page:color" content="#38bdf8">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Roboto+Mono:wght@400;500&display=swap');
        
        :root {
            --sky-400: #38bdf8;
            --sky-500: #0ea5e9;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 #f1f5f9;
        }

        .font-mono { font-family: 'Roboto Mono', monospace; }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 10px; border: 2px solid #f1f5f9; }

        .loader { width: 56px; height: 56px; border-radius: 50%; display: inline-block; position: relative; border: 3px solid; border-color: #d1d5db #d1d5db transparent transparent; box-sizing: border-box; animation: rotation 1s linear infinite; }
        .loader::after, .loader::before { content: ''; box-sizing: border-box; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; border: 3px solid; border-color: transparent transparent var(--sky-400) var(--sky-400); width: 40px; height: 40px; border-radius: 50%; box-sizing: border-box; animation: rotationBack 0.5s linear infinite; transform-origin: center center; }
        .loader::before { width: 28px; height: 28px; border-color: #d1d5db #d1d5db transparent transparent; animation: rotation 1.5s linear infinite; }
        
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } 
        @keyframes rotationBack { 0% { transform: rotate(0deg); } 100% { transform: rotate(-360deg); } }

        .stagger-card { transform: translateY(30px); opacity: 0; animation: slide-up-fade-in 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
        @keyframes slide-up-fade-in { to { transform: translateY(0); opacity: 1; } }
        
        .fade-in { animation: fadeIn 0.5s ease-in-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .tooltip-arrow::before { content: ''; position: absolute; width: 0; height: 0; border-style: solid; border-width: 0 6px 6px 6px; border-color: transparent transparent #e5e7eb transparent; bottom: 100%; left: 50%; transform: translateX(-50%); }
        
        #plot-container .svg-container { margin: auto; }

    </style>
</head>

<body class="bg-gray-50 text-gray-800">

    <div id="loading-overlay" class="fixed inset-0 bg-white/80 backdrop-blur-sm flex flex-col justify-center items-center z-50 transition-opacity duration-500">
        <div class="loader"></div>
        <p id="loading-text" class="mt-6 text-gray-700 font-medium text-lg">辞書データを準備しています...</p>
        <div class="w-64 bg-gray-200 rounded-full h-2 mt-4 overflow-hidden">
            <div id="loading-progress" class="bg-sky-400 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
    </div>
    
    <div id="model-status" class="hidden fixed top-4 right-4 bg-indigo-50 border-l-4 border-indigo-500 text-indigo-800 p-4 rounded-r-lg shadow-lg z-40 transition-all duration-500 max-w-sm">
        <div class="flex items-center">
            <i class="fas fa-spinner fa-spin mr-3 text-xl"></i>
            <span id="model-status-text">意味検索用のAIモデルを読み込んでいます...</span>
        </div>
    </div>


    <div id="app-container" class="grid grid-cols-1 md:grid-cols-12 min-h-screen opacity-0 transition-opacity duration-500">
        <aside class="md:col-span-4 lg:col-span-3 xl:col-span-3 bg-white border-r border-gray-200 p-6 flex flex-col h-screen">
            <header class="mb-6">
                <div class="flex items-center space-x-3">
                    <i class="fas fa-wave-square text-3xl text-sky-400"></i>
                    <h1 class="text-2xl font-bold text-gray-900">AI Rhyme Finder</h1>
                </div>
                <p class="mt-1 text-sm text-gray-500">AIによる意味検索付き押韻ツール</p>
            </header>

            <div class="relative group mb-4">
                <label for="searchInput" class="sr-only">韻を検索</label>
                <input type="text" id="searchInput" placeholder="韻を検索 (例: 簡単, a?an)" class="w-full pl-10 pr-20 py-3 text-base bg-gray-100 border-2 border-transparent rounded-lg focus:ring-2 focus:ring-sky-300 focus:bg-white focus:border-sky-400 outline-none transition-all duration-300">
                <i class="fas fa-search text-gray-400 absolute left-4 top-1/2 -translate-y-1/2"></i>
                <div class="absolute right-12 top-1/2 -translate-y-1/2">
                    <i class="fas fa-question-circle text-gray-400 peer cursor-help"></i>
                    <div class="invisible peer-hover:visible absolute z-10 w-64 p-3 text-sm font-light text-gray-600 bg-white rounded-lg border border-gray-200 shadow-lg bottom-full mb-2 left-1/2 -translate-x-1/2" role="tooltip">
                        <p class="font-sans">単語または母音 (<b class="font-mono text-gray-800">a,i,u,e,o,n</b>) で検索できます。<br>
                        <code class="font-mono bg-gray-100 text-xs py-0.5 px-1 rounded">?</code> は任意の1母音に一致します。</p>
                        <div class="tooltip-arrow border-gray-200"></div>
                    </div>
                </div>
                <button id="searchButton" class="absolute inset-y-0 right-0 flex items-center justify-center w-12 text-gray-500 hover:text-sky-500 transition-colors">
                    <i class="fas fa-arrow-right"></i>
                </button>
            </div>
            
            <div class="mb-6 border-t border-b border-gray-200 py-4">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-sm font-bold text-gray-500 uppercase tracking-wider">辞書フィルター</h2>
                    <div class="space-x-2">
                        <button id="filter-select-all" class="text-xs text-sky-600 hover:text-sky-800 font-medium">全選択</button>
                        <button id="filter-deselect-all" class="text-xs text-gray-500 hover:text-gray-800 font-medium">全解除</button>
                    </div>
                </div>
                <div id="dictionary-filter-list" class="flex flex-wrap gap-2"></div>
            </div>

            <div class="flex-grow flex flex-col min-h-0">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-sm font-bold text-gray-500 uppercase tracking-wider">検索履歴</h2>
                    <button id="clearHistoryButton" class="text-xs text-gray-400 hover:text-red-500 transition-colors" title="履歴を消去">
                        <i class="fas fa-trash-alt mr-1"></i>消去
                    </button>
                </div>
                <ul id="historyList" class="flex-grow space-y-1 overflow-y-auto pr-1"></ul>
            </div>

            <footer class="text-center mt-6 text-gray-400 text-xs">
                <p>Powered by Transformers.js & Plotly.js</p>
            </footer>
        </aside>

        <main class="md:col-span-8 lg:col-span-9 xl:col-span-9 bg-gray-50 p-4 md:p-8 flex flex-col h-screen">
            <div id="results-header" class="hidden mb-4 p-4 bg-white rounded-lg border border-gray-200 flex flex-col gap-4">
                <div class="w-full flex flex-col sm:flex-row justify-between items-center gap-4">
                    <p id="results-summary" class="text-gray-700 text-center sm:text-left"></p>
                    <div class="flex items-center space-x-4">
                         <button id="visualize-button" class="hidden bg-indigo-100 text-indigo-700 font-medium py-2 px-4 rounded-lg hover:bg-indigo-200 transition-colors text-sm flex items-center gap-2">
                            <i class="fas fa-project-diagram"></i>可視化
                        </button>
                        <div class="flex items-center space-x-2">
                            <label for="limit-select" class="text-sm text-gray-600 shrink-0">表示件数:</label>
                            <input type="number" id="limit-select" value="50" min="1" max="500" class="w-20 text-sm bg-gray-100 border-gray-300 rounded-md py-1 px-2 focus:ring-sky-300 focus:border-sky-300">
                        </div>
                    </div>
                </div>

                <div id="vector-search-container" class="hidden w-full pt-4 border-t border-gray-200">
                     <label for="vectorQueryInput" class="block text-sm font-bold text-gray-600 mb-2">
                        <i class="fas fa-wand-magic-sparkles mr-1 text-indigo-400"></i>結果を意味で絞り込み (ベクトル検索)
                    </label>
                    <div class="relative">
                        <input type="text" id="vectorQueryInput" placeholder="例: 前向きな気持ち" class="w-full pl-4 pr-28 py-2 text-base bg-gray-100 border-2 border-gray-200 rounded-lg focus:ring-2 focus:ring-indigo-400 focus:bg-white focus:border-indigo-400 outline-none transition-all duration-300" disabled>
                        <button id="vectorSearchButton" class="absolute inset-y-1 right-1 flex items-center justify-center w-24 px-4 py-2 bg-indigo-500 text-white font-bold rounded-md hover:bg-indigo-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                            <span id="vector-btn-text">検索</span>
                        </button>
                    </div>
                </div>
            </div>

            <div id="results-section" class="flex-grow overflow-y-auto pr-2">
                <div id="welcome-message" class="flex flex-col items-center justify-center h-full text-center bg-white rounded-lg border-2 border-dashed border-gray-300 p-8">
                    <i class="fas fa-keyboard text-5xl text-gray-300 mb-6"></i>
                    <h2 class="text-2xl font-bold text-gray-700">ようこそ</h2>
                    <p class="mt-2 max-w-md text-gray-500">左のパネルで単語や母音列を入力して韻を検索してください。ワイルドカード(<code class="font-mono bg-gray-200 text-xs py-0.5 px-1 rounded">?</code>)も使えます。</p>
                </div>
            </div>
        </main>
    </div>

    <div id="detail-modal-container"></div>
    
    <script type="importmap">{ "imports": { "@xenova/transformers": "https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.5.2/dist/transformers.min.js" } }</script>
    <script type="module">
        import { pipeline, cos_sim } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.5.2/dist/transformers.min.js';
        import TSNE from 'https://cdn.jsdelivr.net/npm/tsne-js@1.0.3/+esm';

        class PrefixTree {
            constructor() { this.root = new Node(); }
            add(word, wordObject) { let node = this.root; for (let i = 0; i < word.length; i++) { let c = word[i]; if (!node.children[c]) { node.children[c] = new Node(); } node = node.children[c]; } word = word.split('').reverse().join(''); node.values.add(wordObject); node.vowel = word; }
            searchAll(word) { let node = this.root; for (let i = 0; i < word.length; i++) { let c = word[i]; if (!node.children[c]) { return []; } node = node.children[c]; } return this._searchAll(node); }
            _searchAll(node) { let res = []; if (node.values.size > 0) { res.push({ vowel: node.vowel, set: node.values }); } for (let c in node.children) { res = res.concat(this._searchAll(node.children[c])); } return res; }
            searchWithWildcard(pattern) { const results = this._searchWithWildcardRecursive(this.root, pattern); return this.mergeResults(results); }
            _searchWithWildcardRecursive(node, subpattern) { if (!node) return []; if (subpattern.length === 0) { return this._searchAll(node); } const char = subpattern[0]; const remainingPattern = subpattern.substring(1); let results = []; if (char === '?') { const wildcards = ['a', 'i', 'u', 'e', 'o', 'n']; for (const wc of wildcards) { if (node.children[wc]) { results.push(...this._searchWithWildcardRecursive(node.children[wc], remainingPattern)); } } } else { if (node.children[char]) { results.push(...this._searchWithWildcardRecursive(node.children[char], remainingPattern)); } } return results; }
            mergeResults(results) { const merged = new Map(); for (const result of results) { const currentSet = merged.get(result.vowel); if (currentSet) { for (const wordObj of result.set) { currentSet.add(wordObj); } } else { merged.set(result.vowel, new Set(result.set)); } } return Array.from(merged.entries()).map(([vowel, set]) => ({ vowel, set })); }
        }
        class Node { constructor() { this.children = {}; this.values = new Set(); this.vowel = null; } }
        class YomiUtil {
            constructor() {
                this.roma_to_hira = { "a": "あ", "ba": "ば", "be": "べ", "bi": "び", "bo": "ぼ", "bu": "ぶ", "bya": "びゃ", "bye": "びぇ", "byi": "びぃ", "byo": "びょ", "byu": "びゅ", "ca": "か", "ce": "せ", "cha": "ちゃ", "che": "ちぇ", "chi": "ち", "cho": "ちょ", "chu": "ちゅ", "ci": "し", "co": "こ", "cu": "く", "cya": "ちゃ", "cye": "ちぇ", "cyi": "ちぃ", "cyo": "ちょ", "cyu": "ちゅ", "da": "だ", "de": "で", "dha": "でゃ", "dhe": "でぇ", "dhi": "でぃ", "dho": "でょ", "dhu": "でゅ", "di": "ぢ", "do": "ど", "du": "づ", "dwa": "どぁ", "dwe": "どぇ", "dwi": "どぃ", "dwo": "どぉ", "dwu": "どぅ", "dya": "ぢゃ", "dye": "ぢぇ", "dyi": "ぢぃ", "dyo": "ぢょ", "dyu": "ぢゅ", "e": "え", "fa": "ふぁ", "fe": "ふぇ", "fi": "ふぃ", "fo": "ふぉ", "fu": "ふ", "fwa": "ふぁ", "fwe": "ふぇ", "fwi": "ふぃ", "fwo": "ふぉ", "fwu": "ふぅ", "fya": "ふゃ", "fye": "ふぇ", "fyi": "ふぃ", "fyo": "ふょ", "fyu": "ふゅ", "ga": "が", "ge": "げ", "gi": "ぎ", "go": "ご", "gu": "ぐ", "gwa": "ぐぁ", "gwe": "ぐぇ", "gwi": "ぐぃ", "gwo": "ぐぉ", "gwu": "ぐぅ", "gya": "ぎゃ", "gye": "ぎぇ", "gyi": "ぎぃ", "gyo": "ぎょ", "gyu": "ぎゅ", "ha": "は", "he": "へ", "hi": "ひ", "ho": "ほ", "hu": "ふ", "hya": "ひゃ", "hye": "ひぇ", "hyi": "ひぃ", "hyo": "ひょ", "hyu": "ひゅ", "i": "い", "ja": "じゃ", "je": "じぇ", "ji": "じ", "jo": "じょ", "ju": "じゅ", "jya": "じゃ", "jye": "じぇ", "jyi": "じぃ", "jyo": "じょ", "jyu": "じゅ", "ka": "か", "ke": "け", "ki": "き", "ko": "こ", "ku": "く", "kwa": "くぁ", "kya": "きゃ", "kye": "きぇ", "kyi": "きぃ", "kyo": "きょ", "kyu": "きゅ", "la": "ぁ", "le": "ぇ", "li": "ぃ", "lka": "ヵ", "lke": "ヶ", "lo": "ぉ", "lu": "ぅ", "lwa": "ゎ", "lya": "ゃ", "lye": "ぇ", "lyi": "ぃ", "lyo": "ょ", "lyu": "ゅ", "ma": "ま", "me": "め", "mi": "み", "mo": "も", "mu": "む", "mya": "みゃ", "mye": "みぇ", "myi": "みぃ", "myo": "みょ", "myu": "みゅ", "n": "ん", "na": "な", "ne": "ね", "ni": "に", "nn": "ん", "no": "の", "nu": "ぬ", "nya": "にゃ", "nye": "にぇ", "nyi": "にぃ", "nyo": "にょ", "nyu": "にゅ", "o": "お", "pa": "ぱ", "pe": "ぺ", "pi": "ぴ", "po": "ぽ", "pu": "ぷ", "pya": "ぴゃ", "pye": "ぴぇ", "pyi": "ぴぃ", "pyo": "ぴょ", "pyu": "ぴゅ", "qa": "くぁ", "qe": "くぇ", "qi": "くぃ", "qo": "くぉ", "qu": "く", "qwa": "くぁ", "qwe": "くぇ", "qwi": "くぃ", "qwo": "くぉ", "qwu": "くぅ", "qya": "くゃ", "qye": "くぇ", "qyi": "くぃ", "qyo": "くょ", "qyu": "くゅ", "ra": "ら", "re": "れ", "ri": "り", "ro": "ろ", "ru": "る", "rya": "りゃ", "rye": "りぇ", "ryi": "りぃ", "ryo": "りょ", "ryu": "りゅ", "sa": "さ", "se": "せ", "sha": "しゃ", "she": "しぇ", "shi": "し", "sho": "しょ", "shu": "しゅ", "si": "し", "so": "そ", "su": "す", "swa": "すぁ", "swe": "すぇ", "swi": "すぃ", "swo": "すぉ", "swu": "すぅ", "sya": "しゃ", "sye": "しぇ", "syi": "しぃ", "syo": "しょ", "syu": "しゅ", "ta": "た", "te": "て", "tha": "てゃ", "the": "てぇ", "thi": "てぃ", "tho": "てょ", "thu": "てゅ", "ti": "ち", "to": "と", "tsa": "つぁ", "tse": "つぇ", "tsi": "つぃ", "tso": "つぉ", "tsu": "つ", "tu": "つ", "twa": "とぁ", "twe": "とぇ", "twi": "とぃ", "two": "とぉ", "twu": "とぅ", "tya": "ちゃ", "tye": "ちぇ", "tyi": "ちぃ", "tyo": "ちょ", "tyu": "ちゅ", "u": "う", "va": "ヴぁ", "ve": "ヴぇ", "vi": "ヴぃ", "vo": "ヴぉ", "vu": "ヴ", "vya": "ヴゃ", "vye": "ヴぇ", "vyi": "ヴぃ", "vyo": "ヴょ", "vyu": "ヴゅ", "wa": "わ", "we": "うぇ", "wha": "うぁ", "whe": "うぇ", "whi": "うぃ", "who": "うぉ", "whu": "う", "wi": "うぃ", "wo": "を", "wu": "う", "wye": "ゑ", "wyi": "ゐ", "xa": "ぁ", "xe": "ぇ", "xi": "ぃ", "xka": "ヵ", "xke": "ヶ", "xo": "ぉ", "xu": "ぅ", "xwa": "ゎ", "xya": "ゃ", "xye": "ぇ", "xyi": "ぃ", "xyo": "ょ", "xyu": "ゅ", "ya": "や", "ye": "いぇ", "yi": "い", "yo": "よ", "yu": "ゆ", "za": "ざ", "ze": "ぜ", "zi": "じ", "zo": "ぞ", "zu": "ず", "zya": "じゃ", "zye": "じぇ", "zyi": "じぃ", "zyo": "じょ", "zyu": "じゅ", }
                this.kana_to_roma = {}; for (let roma in this.roma_to_hira) { let hira = this.roma_to_hira[roma]; let kana = this.hira2kana(hira); if (this.kana_to_roma[kana]) continue; this.kana_to_roma[kana] = roma; }
            }
            hira2kana(str) { return str.replace(/[\u3041-\u3096]/g, match => String.fromCharCode(match.charCodeAt(0) + 0x60)); }
            kana2roma(str) { const res = []; let i = 0; while (i < str.length) { let c = str[i]; if (i + 1 < str.length) { let cc = c + str[i + 1]; if (this.kana_to_roma[cc]) { res.push(this.kana_to_roma[cc]); i += 2; continue; } } if (this.kana_to_roma[c]) { res.push(this.kana_to_roma[c]); } i++; } return res; }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const dom = {
                loadingOverlay: document.getElementById('loading-overlay'), loadingText: document.getElementById('loading-text'), loadingProgress: document.getElementById('loading-progress'),
                modelStatus: document.getElementById('model-status'), modelStatusText: document.getElementById('model-status-text'),
                appContainer: document.getElementById('app-container'),
                searchInput: document.getElementById('searchInput'), searchButton: document.getElementById('searchButton'),
                historyList: document.getElementById('historyList'), clearHistoryButton: document.getElementById('clearHistoryButton'),
                resultsHeader: document.getElementById('results-header'), resultsSummary: document.getElementById('results-summary'), resultsSection: document.getElementById('results-section'), welcomeMessage: document.getElementById('welcome-message'),
                vectorSearchContainer: document.getElementById('vector-search-container'), vectorQueryInput: document.getElementById('vectorQueryInput'), vectorSearchButton: document.getElementById('vectorSearchButton'), vectorBtnText: document.getElementById('vector-btn-text'),
                visualizeButton: document.getElementById('visualize-button'),
                limitSelect: document.getElementById('limit-select'),
                dictionaryFilterList: document.getElementById('dictionary-filter-list'), filterSelectAll: document.getElementById('filter-select-all'), filterDeselectAll: document.getElementById('filter-deselect-all'),
                detailModalContainer: document.getElementById('detail-modal-container'),
            };

            const YU = new YomiUtil();
            const pt = new PrefixTree();
            const wordToReadingMap = new Map();
            const wordDetailsMap = new Map();
            let searchHistory = JSON.parse(localStorage.getItem('rhymeSearchHistory')) || [];
            let currentRhymeResults = [];
            let lastVectorData = null;

            let extractor = null;
            let isModelReady = false;

            const csvList = [
                "../Assets/dict/Adj.csv", "../Assets/dict/Adnominal.csv", "../Assets/dict/Adverb.csv", "../Assets/dict/Auxil.csv",
                "../Assets/dict/Conjunction.csv", "../Assets/dict/Filler.csv", "../Assets/dict/Interjection.csv",
                "../Assets/dict/Noun.adjv.csv", "../Assets/dict/Noun.adverbal.csv", "../Assets/dict/Noun.csv",
                "../Assets/dict/Noun.demonst.csv", "../Assets/dict/Noun.nai.csv", "../Assets/dict/Noun.name.csv",
                "../Assets/dict/Noun.number.csv", "../Assets/dict/Noun.org.csv", "../Assets.ipac/Noun.others.csv",
                "../Assets/dict/Noun.place.csv", "../Assets/dict/Noun.proper.csv", "../Assets/dict/Noun.verbal.csv",
                "../Assets/dict/Others.csv", "../Assets/dict/Postp-col.csv", "../Assets/dict/Postp.csv",
                "../Assets/dict/Prefix.csv", "../Assets/dict/Suffix.csv", "../Assets/dict/Symbol.csv", "../Assets/dict/Verb.csv"
            ];
            
            const dictionaryConfig = {
                'Noun': { name: '名詞', color: 'blue' }, 'Verb': { name: '動詞', color: 'green' }, 'Adj': { name: '形容詞', color: 'pink' }, 'Adverb': { name: '副詞', color: 'purple' }, 'Adnominal': { name: '連体詞', color: 'fuchsia' }, 'Conjunction': { name: '接続詞', color: 'indigo' }, 'Interjection': { name: '感動詞', color: 'yellow' }, 'Postp': { name: '助詞', color: 'cyan' }, 'Auxil': { name: '助動詞', color: 'violet' }, 'Prefix': { name: '接頭辞', color: 'emerald' }, 'Suffix': { name: '接尾辞', color: 'lime' }, 'Symbol': { name: '記号', color: 'orange' }, 'Filler': { name: 'フィラー', color: 'gray' }, 'Others': { name: 'その他', color: 'slate' }
            };

            function getTailwindColorClasses(source) {
                const color = dictionaryConfig[source]?.color || 'gray';
                const classMap = { 'pink': 'bg-pink-100 text-pink-800 hover:bg-pink-200 hover:border-pink-400', 'fuchsia': 'bg-fuchsia-100 text-fuchsia-800 hover:bg-fuchsia-200 hover:border-fuchsia-400', 'purple': 'bg-purple-100 text-purple-800 hover:bg-purple-200 hover:border-purple-400', 'violet': 'bg-violet-100 text-violet-800 hover:bg-violet-200 hover:border-violet-400', 'indigo': 'bg-indigo-100 text-indigo-800 hover:bg-indigo-200 hover:border-indigo-400', 'gray': 'bg-gray-100 text-gray-800 hover:bg-gray-200 hover:border-gray-400', 'yellow': 'bg-yellow-100 text-yellow-800 hover:bg-yellow-200 hover:border-yellow-400', 'blue': 'bg-blue-100 text-blue-800 hover:bg-blue-200 hover:border-blue-400', 'slate': 'bg-slate-100 text-slate-800 hover:bg-slate-200 hover:border-slate-400', 'cyan': 'bg-cyan-100 text-cyan-800 hover:bg-cyan-200 hover:border-cyan-400', 'emerald': 'bg-emerald-100 text-emerald-800 hover:bg-emerald-200 hover:border-emerald-400', 'lime': 'bg-lime-100 text-lime-800 hover:bg-lime-200 hover:border-lime-400', 'orange': 'bg-orange-100 text-orange-800 hover:bg-orange-200 hover:border-orange-400', 'green': 'bg-green-100 text-green-800 hover:bg-green-200 hover:border-green-400', };
                return classMap[color] || classMap['gray'];
            }
            
            function getTailwindFilterChipColors(color) {
                const sets = { 'pink':      { base: 'bg-white', text: 'text-pink-700',    border: 'border-pink-300',    hover: 'hover:bg-pink-50 hover:border-pink-400',    checked_bg: 'bg-pink-500',    checked_text: 'text-white', checked_border: 'border-pink-500' }, 'fuchsia':   { base: 'bg-white', text: 'text-fuchsia-700', border: 'border-fuchsia-300', hover: 'hover:bg-fuchsia-50 hover:border-fuchsia-400', checked_bg: 'bg-fuchsia-500', checked_text: 'text-white', checked_border: 'border-fuchsia-500' }, 'purple':    { base: 'bg-white', text: 'text-purple-700',  border: 'border-purple-300',  hover: 'hover:bg-purple-50 hover:border-purple-400',  checked_bg: 'bg-purple-500',  checked_text: 'text-white', checked_border: 'border-purple-500' }, 'violet':    { base: 'bg-white', text: 'text-violet-700',  border: 'border-violet-300',  hover: 'hover:bg-violet-50 hover:border-violet-400',  checked_bg: 'bg-violet-500',  checked_text: 'text-white', checked_border: 'border-violet-500' }, 'indigo':    { base: 'bg-white', text: 'text-indigo-700',  border: 'border-indigo-300',  hover: 'hover:bg-indigo-50 hover:border-indigo-400',  checked_bg: 'bg-indigo-500',  checked_text: 'text-white', checked_border: 'border-indigo-500' }, 'blue':      { base: 'bg-white', text: 'text-blue-700',    border: 'border-blue-300',    hover: 'hover:bg-blue-50 hover:border-blue-400',    checked_bg: 'bg-blue-500',    checked_text: 'text-white', checked_border: 'border-blue-500' }, 'cyan':      { base: 'bg-white', text: 'text-cyan-700',    border: 'border-cyan-300',    hover: 'hover:bg-cyan-50 hover:border-cyan-400',    checked_bg: 'bg-cyan-500',    checked_text: 'text-white', checked_border: 'border-cyan-500' }, 'green':     { base: 'bg-white', text: 'text-green-700',   border: 'border-green-300',   hover: 'hover:bg-green-50 hover:border-green-400',   checked_bg: 'bg-green-500',   checked_text: 'text-white', checked_border: 'border-green-500' }, 'lime':      { base: 'bg-white', text: 'text-lime-700',    border: 'border-lime-300',    hover: 'hover:bg-lime-50 hover:border-lime-400',    checked_bg: 'bg-lime-500',    checked_text: 'text-white', checked_border: 'border-lime-500' }, 'yellow':    { base: 'bg-white', text: 'text-yellow-700',  border: 'border-yellow-300',  hover: 'hover:bg-yellow-50 hover:border-yellow-400',  checked_bg: 'bg-yellow-500',  checked_text: 'text-white', checked_border: 'border-yellow-500' }, 'orange':    { base: 'bg-white', text: 'text-orange-700',  border: 'border-orange-300',  hover: 'hover:bg-orange-50 hover:border-orange-400',  checked_bg: 'bg-orange-500',  checked_text: 'text-white', checked_border: 'border-orange-500' }, 'slate':     { base: 'bg-white', text: 'text-slate-700',   border: 'border-slate-300',   hover: 'hover:bg-slate-50 hover:border-slate-400',   checked_bg: 'bg-slate-500',   checked_text: 'text-white', checked_border: 'border-slate-500' }, 'gray':      { base: 'bg-white', text: 'text-gray-700',    border: 'border-gray-300',    hover: 'hover:bg-gray-50 hover:border-gray-400',    checked_bg: 'bg-gray-500',    checked_text: 'text-white', checked_border: 'border-gray-500' }, };
                return sets[color] || sets['gray'];
            }

            function getTypeFromPath(path) { const fileName = path.split('/').pop(); const baseType = fileName.split('.')[0]; return dictionaryConfig[baseType] ? baseType : 'Others'; }
            function getReversedVowelString(kanaString) { if (!kanaString) return ''; const cleanKana = kanaString.replace(/ー/g, ''); const romajiArray = YU.kana2roma(cleanKana); if (!romajiArray) return ''; return romajiArray.map(e => e[e.length - 1]).reverse().join(''); }

            async function initialize() {
                initializeModel();
                try {
                    let loadedCount = 0;
                    for (const csvPath of csvList) {
                        try {
                             const response = await fetch(csvPath);
                            if (!response.ok) { console.warn(`Could not load ${csvPath}, skipping.`); continue; }
                            const data = await response.text();
                            const rows = data.trim().split('\n');
                            const source = getTypeFromPath(csvPath);
                            for (const line of rows) {
                                const row = line.split(',');
                                if (row && row.length > 11 && row[0] && row[11]) {
                                    const surfaceWord = row[0];
                                    const yomi = row[11];
                                    if (!wordDetailsMap.has(surfaceWord)) { wordDetailsMap.set(surfaceWord, []); }
                                    const detail = { surface: row[0] || '', pos1: row[4] || '*', pos2: row[5] || '*', pos3: row[6] || '*', pos4: row[7] || '*', conjForm: row[8] || '*', conjType: row[9] || '*', baseForm: row[10] || '*', yomi: row[11] || '', pronunciation: row[12] || '', source: source };
                                    wordDetailsMap.get(surfaceWord).push(detail);
                                    if (!wordToReadingMap.has(surfaceWord)) wordToReadingMap.set(surfaceWord, { yomi, source });
                                    const reversedVowels = getReversedVowelString(yomi);
                                    if (reversedVowels) pt.add(reversedVowels, { word: surfaceWord, source, yomi });
                                }
                            }
                        } catch (e) { console.warn(`Error processing ${csvPath}, skipping.`, e); }
                        loadedCount++;
                        const progress = (loadedCount / csvList.length) * 100;
                        dom.loadingProgress.style.width = `${progress}%`;
                        dom.loadingText.textContent = `辞書を処理中... (${loadedCount}/${csvList.length})`;
                    }
                    setupFilters();
                    dom.loadingOverlay.classList.add('opacity-0', 'pointer-events-none');
                    dom.appContainer.classList.remove('opacity-0');
                    dom.searchInput.focus();
                    updateHistoryUI();
                } catch (error) {
                    console.error('Initialization failed:', error);
                    dom.loadingText.innerHTML = `エラー: 辞書ファイルの読み込みに失敗しました。<br>ファイルが指定の場所にあるか確認してください。`;
                    dom.loadingText.classList.add('text-red-500');
                    dom.loadingProgress.parentElement.classList.add('hidden');
                }
            }
            
            async function initializeModel() {
                try {
                    dom.modelStatus.classList.remove('hidden');
                    extractor = await pipeline('feature-extraction','Xenova/multilingual-e5-large',{
                        quantized: true,
                        progress_callback: (progress) => {
                             if(progress.status === 'progress' && progress.progress) {
                                const percentage = (progress.progress).toFixed(2);
                                dom.modelStatusText.textContent = `AIモデルをダウンロード中... (${percentage}%)`;
                            } else {
                                dom.modelStatusText.textContent = `AIモデルを準備中... (${progress.status})`;
                            }
                        }
                    });

                    dom.modelStatus.classList.remove('bg-indigo-50','border-indigo-500','text-indigo-800');
                    dom.modelStatus.classList.add('bg-green-50','border-green-500','text-green-800');
                    dom.modelStatus.querySelector('i').classList.remove('fa-spinner','fa-spin');
                    dom.modelStatus.querySelector('i').classList.add('fa-check-circle');
                    dom.modelStatusText.textContent = 'AIモデルの準備が完了しました。';
                    isModelReady = true;
                    dom.vectorQueryInput.disabled = false;
                    dom.vectorQueryInput.placeholder = "例: 前向きな気持ち";
                    dom.vectorSearchButton.disabled = false;

                    setTimeout(() => {
                        dom.modelStatus.style.opacity = '0';
                        setTimeout(() => dom.modelStatus.style.display = 'none', 500);
                    }, 2500);

                } catch(error) {
                    dom.modelStatusText.textContent = 'AIモデルの読み込みに失敗しました。';
                    console.error("Model loading error:", error);
                    dom.modelStatus.classList.remove('bg-indigo-50','border-indigo-500','text-indigo-800');
                    dom.modelStatus.classList.add('bg-red-50','border-red-500','text-red-800');
                    dom.modelStatus.querySelector('i').classList.remove('fa-spinner','fa-spin');
                    dom.modelStatus.querySelector('i').classList.add('fa-exclamation-triangle');
                }
            }
            
            function setupFilters() {
                dom.dictionaryFilterList.innerHTML = '';
                Object.entries(dictionaryConfig).forEach(([key, {name, color}]) => {
                    const colors = getTailwindFilterChipColors(color);
                    const label = document.createElement('label');
                    label.className = `cursor-pointer`;
                    label.innerHTML = `<input type="checkbox" data-filter-type="${key}" class="filter-checkbox sr-only peer" checked>
                        <span class="peer-checked:${colors.checked_bg} peer-checked:${colors.checked_text} peer-checked:${colors.checked_border} ${colors.base} ${colors.text} ${colors.border} inline-block text-xs font-medium px-3 py-1.5 rounded-full border-2 transition-all duration-200 ${colors.hover}">${name}</span>`;
                    dom.dictionaryFilterList.appendChild(label);
                });
            }
            
            function updateHistoryUI() {
                dom.historyList.innerHTML = '';
                if (searchHistory.length === 0) {
                    dom.historyList.innerHTML = `<li class="text-center text-sm text-gray-400 px-3 py-2">履歴はありません</li>`;
                    dom.clearHistoryButton.classList.add('hidden');
                } else {
                    searchHistory.forEach(term => {
                        const li = document.createElement('li');
                        li.className = 'group flex justify-between items-center rounded-md hover:bg-gray-100 cursor-pointer text-gray-700';
                        li.innerHTML = `<span class="history-term flex-grow px-3 py-2">${term}</span>
                                        <button class="history-delete text-gray-400 hover:text-red-500 w-8 h-8 flex items-center justify-center rounded-full opacity-0 group-hover:opacity-100 transition-opacity" data-term="${term}"><i class="fas fa-times"></i></button>`;
                        dom.historyList.appendChild(li);
                    });
                    dom.clearHistoryButton.classList.remove('hidden');
                }
            }

            function addToHistory(term) {
                if (!term) return;
                searchHistory = searchHistory.filter(t => t.toLowerCase() !== term.toLowerCase());
                searchHistory.unshift(term);
                if (searchHistory.length > 20) searchHistory.pop();
                localStorage.setItem('rhymeSearchHistory', JSON.stringify(searchHistory));
                updateHistoryUI();
            }

            function displayRhymeResults(query, isVowelSearch = false) {
                const activeFilters = new Set(Array.from(document.querySelectorAll('.filter-checkbox:checked')).map(cb => cb.dataset.filterType));
                
                let filteredResults = currentRhymeResults.map(group => ({
                    ...group,
                    set: new Set(Array.from(group.set).filter(wordObj => activeFilters.has(wordObj.source)))
                })).filter(group => group.set.size > 0);
                
                filteredResults.sort((a, b) => b.set.size - a.set.size || b.vowel.length - a.vowel.length);
                
                const limit = parseInt(dom.limitSelect.value, 10) || 50;
                const limitedResults = filteredResults.slice(0, limit);
                
                dom.resultsSection.innerHTML = '';
                dom.welcomeMessage.classList.add('hidden');
                dom.vectorSearchContainer.classList.remove('hidden');
                dom.visualizeButton.classList.add('hidden');

                let summaryText;
                if (isVowelSearch) {
                    summaryText = `母音: <span class="font-bold text-sky-500 font-mono">${query}</span>`;
                } else {
                    const readingInfo = wordToReadingMap.get(query);
                    const readingVowels = readingInfo ? getReversedVowelString(readingInfo.yomi).split('').reverse().join('') : '不明';
                    summaryText = `「<span class="font-bold text-sky-500">${query}</span>」 (母音: <span class="font-mono">${readingVowels}</span>)`;
                }

                if (limitedResults.length === 0) {
                    dom.resultsHeader.classList.remove('hidden');
                    dom.resultsSummary.innerHTML = `${summaryText} に一致する単語は見つかりませんでした。`;
                    dom.resultsSection.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-center bg-white rounded-lg border-2 border-dashed border-gray-300 p-8">
                        <i class="fas fa-search-minus text-5xl text-gray-300 mb-6"></i>
                        <h2 class="text-2xl font-bold text-gray-700">結果なし</h2>
                        <p class="mt-2 max-w-md text-gray-500">別の単語で試すか、フィルター設定を確認してください。</p>
                    </div>`;
                    return;
                }

                dom.resultsHeader.classList.remove('hidden');
                const totalWords = filteredResults.reduce((acc, r) => acc + r.set.size, 0);
                dom.resultsSummary.innerHTML = `${summaryText} の検索結果: <span class="font-bold">${totalWords}</span>語（上位${limitedResults.length}件のグループを表示）`;

                limitedResults.forEach((result, index) => {
                    const card = document.createElement('div');
                    card.className = 'stagger-card bg-white border border-gray-200 rounded-xl p-6 mb-4';
                    card.style.animationDelay = `${index * 50}ms`;
                    const vowelSequence = result.vowel.split('').map(v => `<span class="font-mono">${v}</span>`).join('<span class="text-gray-300 mx-px">·</span>');
                    const words = Array.from(result.set).sort((a, b) => a.word.localeCompare(b.word, 'ja'));
                    const wordChips = words.map(wordObj => {
                        const colorClasses = getTailwindColorClasses(wordObj.source);
                        return `<button data-word="${wordObj.word}" class="word-chip ${colorClasses} font-medium py-1.5 px-3 rounded-full border border-transparent text-sm hover:shadow-md transition-all cursor-pointer" title="${dictionaryConfig[wordObj.source]?.name || ''}">${wordObj.word}</button>`
                    }).join('');

                    card.innerHTML = `<div class="flex justify-between items-center mb-4 pb-3 border-b border-gray-200">
                            <h3 class="text-lg font-bold text-sky-600 flex items-center gap-3">
                                <i class="fas fa-signature text-sky-400"></i>母音: <span class="text-gray-800">${vowelSequence}</span>
                            </h3>
                            <span class="text-sm font-medium bg-sky-100 text-sky-700 py-1 px-3 rounded-full">${words.length}語</span>
                        </div>
                        <div class="flex flex-wrap gap-2">${wordChips}</div>`;
                    dom.resultsSection.appendChild(card);
                });
            }

            function performRhymeSearch() {
                const query = dom.searchInput.value.trim();
                if (!query) return;

                const originalSearchButtonIcon = dom.searchButton.innerHTML;
                dom.searchButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;
                dom.searchButton.disabled = true;

                setTimeout(() => {
                    const isVowelQuery = /^[aiueon?]+$/i.test(query);
                    const lowerQuery = query.toLowerCase();

                    if (isVowelQuery) {
                        const reversedPattern = lowerQuery.split('').reverse().join('');
                        currentRhymeResults = lowerQuery.includes('?') ? pt.searchWithWildcard(reversedPattern) : pt.searchAll(reversedPattern);
                    } else {
                        let readingInfo = wordToReadingMap.get(query);
                        let reading = readingInfo ? readingInfo.yomi : YU.hira2kana(query);
                        const reversedVowelsForSearch = getReversedVowelString(reading);
                        currentRhymeResults = reversedVowelsForSearch ? pt.searchAll(reversedVowelsForSearch) : [];
                    }

                    displayRhymeResults(query, isVowelQuery);
                    addToHistory(query);
                    dom.searchButton.innerHTML = originalSearchButtonIcon;
                    dom.searchButton.disabled = false;
                }, 100); 
            }
            
            async function performVectorSearch() {
                if (!isModelReady) { alert('AIモデルがまだ読み込まれていません。'); return; }
                const query = dom.vectorQueryInput.value.trim();
                if (!query) { alert('意味検索のキーワードを入力してください。'); return; }

                const activeFilters = new Set(Array.from(document.querySelectorAll('.filter-checkbox:checked')).map(cb => cb.dataset.filterType));
                const allWordsSet = new Set();
                currentRhymeResults.forEach(group => {
                    group.set.forEach(wordObj => {
                        if (activeFilters.has(wordObj.source)) {
                           allWordsSet.add(wordObj);
                        }
                    });
                });
                
                const allWords = Array.from(allWordsSet).filter(w => w && w.word && w.word.trim() !== '');

                if (allWords.length < 1) { alert('比較対象の単語がありません。'); return; }

                dom.vectorSearchButton.disabled = true;
                dom.vectorBtnText.textContent = '';
                dom.vectorSearchButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;

                try {
                    const textsToEmbed = [query, ...allWords.map(w => w.word)];
                    const embeddings = await extractor(textsToEmbed, { pooling: 'mean', normalize: true });
                    
                    lastVectorData = {
                        embeddings: embeddings,
                        texts: textsToEmbed
                    };
                    
                    const queryEmbedding = embeddings[0].data;
                    const wordEmbeddings = embeddings.slice(1);

                    const rankedWords = allWords.map((wordObj, i) => {
                        if (!wordEmbeddings[i] || !wordEmbeddings[i].data) {
                            return { ...wordObj, score: 0 }; 
                        }
                        const score = cos_sim(queryEmbedding, wordEmbeddings[i].data);
                        return {
                            ...wordObj,
                            score: isNaN(score) ? 0 : score
                        };
                    }).sort((a, b) => b.score - a.score);

                    displayVectorResults(query, rankedWords);
                    dom.visualizeButton.classList.remove('hidden');

                } catch(error) {
                    console.error('Error during vector search:', error);
                    alert('ベクトル検索中にエラーが発生しました。');
                } finally {
                    dom.vectorSearchButton.disabled = false;
                    dom.vectorBtnText.textContent = '検索';
                    dom.vectorSearchButton.innerHTML = `<span id="vector-btn-text">検索</span>`;
                }
            }

            function displayVectorResults(vectorQuery, rankedWords) {
                const limit = parseInt(dom.limitSelect.value, 10) || 50;
                const limitedResults = rankedWords.slice(0, limit);

                dom.resultsSection.innerHTML = '';
                dom.resultsSummary.innerHTML = `「<span class="font-bold text-indigo-500">${vectorQuery}</span>」との意味の近さでソート: <span class="font-bold">${rankedWords.length}</span>語中 <span class="font-bold">${limitedResults.length}</span>件表示`;

                if (limitedResults.length === 0) {
                     dom.resultsSection.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-center bg-white rounded-lg border-2 border-dashed border-gray-300 p-8">
                        <i class="fas fa-search-minus text-5xl text-gray-300 mb-6"></i>
                        <h2 class="text-2xl font-bold text-gray-700">結果なし</h2>
                    </div>`;
                    return;
                }

                const container = document.createElement('div');
                container.className = 'bg-white border border-gray-200 rounded-xl p-4 md:p-6 space-y-3';
                
                limitedResults.forEach((wordObj, index) => {
                    const item = document.createElement('div');
                    const vowel = getReversedVowelString(wordObj.yomi).split('').reverse().join('');
                    const score = wordObj.score;
                    const isScoreValid = score !== null && !isNaN(score);
                    const scoreText = isScoreValid ? score.toFixed(3) : 'N/A';
                    const scorePercentage = isScoreValid ? Math.max(0, score * 100) : 0;
                    
                    item.className = 'stagger-card flex items-center gap-4 p-3 rounded-lg hover:bg-gray-50';
                    item.style.animationDelay = `${index * 30}ms`;

                    item.innerHTML = `
                        <span class="text-gray-400 text-sm font-mono w-8 text-right">${index + 1}</span>
                        <div class="flex-grow">
                            <div class="flex items-center gap-3">
                                <button data-word="${wordObj.word}" class="word-chip text-lg font-bold text-gray-800 hover:text-sky-500 transition-colors">${wordObj.word}</button>
                                <span class="text-xs font-mono text-gray-500 bg-gray-100 px-2 py-0.5 rounded">${vowel}</span>
                            </div>
                        </div>
                        <div class="flex items-center gap-3 w-40">
                            <div class="w-full bg-gray-200 rounded-full h-2">
                                <div class="bg-indigo-400 h-2 rounded-full" style="width: ${scorePercentage}%"></div>
                            </div>
                            <span class="text-sm font-mono text-gray-600 w-12 text-right">${scoreText}</span>
                        </div>
                    `;
                    container.appendChild(item);
                });
                dom.resultsSection.appendChild(container);
            }

            function openDetailModal(word, modalType = 'word') {
                closeAllModals();
                const modalId = `modal-${modalType}-${Date.now()}`;
                const modal = document.createElement('div');
                modal.id = modalId;
                modal.className = 'fixed inset-0 bg-gray-900 bg-opacity-60 backdrop-blur-sm flex justify-center items-center p-4 z-50 opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out';
                
                let modalContentHTML = '';
                if(modalType === 'word'){
                    const details = wordDetailsMap.get(word);
                    if (!details || details.length === 0) return;
                    let detailCards = '';
                    details.forEach((detail, index) => {
                        const pos = [detail.pos1, detail.pos2, detail.pos3, detail.pos4].filter(p => p && p !== '*' && p !== '').join(' - ');
                        const { name, color } = dictionaryConfig[detail.source] || { name: '不明', color: 'gray' };
                        const colors = getTailwindFilterChipColors(color);
                        detailCards += `<div class="bg-white border border-gray-200 rounded-lg p-4">
                            <div class="flex justify-between items-start mb-3">
                                <h4 class="font-bold text-gray-700">エントリー ${index + 1}</h4>
                                <span class="${colors.checked_bg} ${colors.checked_text} text-xs font-bold px-3 py-1 rounded-full">${name}</span>
                            </div>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-3 text-sm">
                                <div class="flex flex-col"><span class="text-xs text-gray-500 font-semibold">読み</span><span class="text-gray-800 font-mono">${detail.yomi || 'N/A'}</span></div>
                                <div class="flex flex-col"><span class="text-xs text-gray-500 font-semibold">発音</span><span class="text-gray-800 font-mono">${detail.pronunciation || 'N/A'}</span></div>
                                <div class="flex flex-col"><span class="text-xs text-gray-500 font-semibold">原形</span><span class="text-gray-800">${detail.baseForm === '*' ? detail.surface : detail.baseForm}</span></div>
                                <div class="flex flex-col col-span-1 sm:col-span-2"><span class="text-xs text-gray-500 font-semibold">品詞</span><span class="text-gray-800">${pos || 'N/A'}</span></div>
                                <div class="flex flex-col"><span class="text-xs text-gray-500 font-semibold">活用形</span><span class="text-gray-800">${detail.conjForm === '*' ? 'N/A' : detail.conjForm}</span></div>
                                <div class="flex flex-col"><span class="text-xs text-gray-500 font-semibold">活用型</span><span class="text-gray-800">${detail.conjType === '*' ? 'N/A' : detail.conjType}</span></div>
                            </div>
                        </div>`;
                    });
                    modalContentHTML = `<div class="flex justify-between items-center p-5 border-b border-gray-200">
                        <h2 class="text-2xl font-bold text-gray-800">${word}</h2>
                        <button class="modal-close-btn text-gray-400 hover:text-gray-700 hover:bg-gray-100 rounded-full w-9 h-9 flex items-center justify-center transition-colors"><i class="fas fa-times text-lg"></i></button>
                    </div>
                    <div class="p-6 flex-grow overflow-y-auto space-y-4 bg-gray-50">${detailCards}</div>`;
                } else if(modalType === 'visualize'){
                    modalContentHTML = `<div class="flex justify-between items-center p-5 border-b border-gray-200">
                        <h2 class="text-2xl font-bold text-gray-800">意味空間の可視化 (t-SNE)</h2>
                        <button class="modal-close-btn text-gray-400 hover:text-gray-700 hover:bg-gray-100 rounded-full w-9 h-9 flex items-center justify-center transition-colors"><i class="fas fa-times text-lg"></i></button>
                    </div>
                    <div class="p-6 flex-grow overflow-y-auto bg-gray-50 flex items-center justify-center">
                        <div id="plot-container" class="w-full h-96 lg:h-[500px] bg-gray-100 rounded-lg"></div>
                    </div>`;
                }

                modal.innerHTML = `<div class="bg-white rounded-2xl shadow-2xl w-full max-w-3xl max-h-[90vh] flex flex-col transform opacity-0 scale-95 transition-all duration-300 ease-in-out">
                    ${modalContentHTML}
                     <div class="p-4 bg-white border-t border-gray-200 rounded-b-2xl text-right">
                        <button class="modal-close-btn bg-gray-200 text-gray-700 font-medium py-2 px-5 rounded-lg hover:bg-gray-300 transition-colors">閉じる</button>
                    </div>
                </div>`;

                dom.detailModalContainer.appendChild(modal);
                document.body.classList.add('overflow-hidden');
                
                modal.classList.remove('opacity-0', 'pointer-events-none');
                requestAnimationFrame(() => {
                    modal.querySelector('.transform').classList.remove('opacity-0', 'scale-95');
                });
                
                if(modalType === 'visualize'){
                    createVectorPlot();
                }

                modal.addEventListener('click', (e) => {
                    if (e.target === modal || e.target.closest('.modal-close-btn')) {
                        closeAllModals();
                    }
                });
            }

            function closeAllModals() {
                const modals = dom.detailModalContainer.querySelectorAll('.fixed');
                modals.forEach(modal => {
                    const panel = modal.querySelector('.transform');
                    if (panel) panel.classList.add('opacity-0', 'scale-95');
                    modal.classList.add('opacity-0');
                    setTimeout(() => {
                        modal.classList.add('pointer-events-none');
                        modal.remove();
                    }, 300);
                });
                if(modals.length > 0) document.body.classList.remove('overflow-hidden');
            }
            
            function createVectorPlot() {
                if(!lastVectorData || !lastVectorData.embeddings) return;
                const plotContainer = document.getElementById('plot-container');
                plotContainer.innerHTML = '<p class="text-gray-500 p-8 text-center">t-SNEを計算中... これには時間がかかる場合があります。</p>';

                setTimeout(() => {
                    const allEmbeddingsData = Array.from(lastVectorData.embeddings, e => Array.from(e.data));
                    const allTexts = lastVectorData.texts;
                    if(allTexts.length < 4) {
                        plotContainer.innerHTML = '<p class="text-red-500 p-8 text-center">t-SNEの計算には4つ以上の単語が必要です。</p>';
                        return;
                    }


                    const nPoints = allEmbeddingsData.length;
                    const perplexity = Math.max(2, Math.min(Math.floor((nPoints - 1) / 3), 30));

                    let model = new TSNE({ dim: 2, perplexity: perplexity, earlyExaggeration: 4.0, learningRate: 100.0, nIter: 500, metric: 'euclidean' });
                    model.init({ data: allEmbeddingsData, type: 'dense' });
                    model.run();
                    const points = model.getOutputScaled();
                    
                    const queryPoint = points[0];
                    const docPoints = points.slice(1);
                    const docTexts = allTexts.slice(1);

                    const docTrace = { x: docPoints.map(p => p[0]), y: docPoints.map(p => p[1]), text: docTexts, mode: 'markers+text', textposition: 'top center', textfont: {size: 10}, type: 'scatter', name: '単語', hovertemplate: '<b>%{text}</b><extra></extra>', marker: { color: '#9ca3af', size: 8, opacity: 0.7 } };
                    const queryTrace = { x: [queryPoint[0]], y: [queryPoint[1]], text: [allTexts[0]], mode: 'markers+text', textposition: 'top center', type: 'scatter', name: 'クエリ', hovertemplate: '<b>%{text}</b><extra></extra>', marker: { color: '#6366f1', size: 16, symbol: 'star' } };
                    
                    const layout = {
                        xaxis: { showgrid: false, zeroline: false, showticklabels: false, visible: false}, yaxis: { showgrid: false, zeroline: false, showticklabels: false, visible: false },
                        paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(243, 244, 246, 1)', showlegend: true,
                        legend: { orientation: "h", yanchor: "bottom", y: 1.02, xanchor: "right", x: 1 },
                        margin: {l: 20, r: 20, b: 20, t: 40}, hovermode: 'closest', font: { family: "'Noto Sans JP', sans-serif", color: '#374151' }
                    };
                    Plotly.newPlot('plot-container', [docTrace, queryTrace], layout, {responsive: true, displaylogo: false});
                }, 100);
            }

            dom.searchButton.addEventListener('click', performRhymeSearch);
            dom.searchInput.addEventListener('keydown', (e) => e.key === 'Enter' && performRhymeSearch());
            dom.vectorSearchButton.addEventListener('click', performVectorSearch);
            dom.vectorQueryInput.addEventListener('keydown', (e) => e.key === 'Enter' && performVectorSearch());

            dom.limitSelect.addEventListener('change', () => {
                const query = dom.searchInput.value.trim();
                if(query) displayRhymeResults(query, /^[aiueon?]+$/i.test(query));
            });
            dom.dictionaryFilterList.addEventListener('change', () => {
                const query = dom.searchInput.value.trim();
                if(query) displayRhymeResults(query, /^[aiueon?]+$/i.test(query));
            });
            
            dom.visualizeButton.addEventListener('click', () => openDetailModal(null, 'visualize'));
            dom.filterSelectAll.addEventListener('click', () => { document.querySelectorAll('.filter-checkbox').forEach(cb => cb.checked = true); dom.dictionaryFilterList.dispatchEvent(new Event('change')); });
            dom.filterDeselectAll.addEventListener('click', () => { document.querySelectorAll('.filter-checkbox').forEach(cb => cb.checked = false); dom.dictionaryFilterList.dispatchEvent(new Event('change')); });
            dom.clearHistoryButton.addEventListener('click', () => { if (confirm('検索履歴をすべて消去しますか？')) { searchHistory = []; localStorage.removeItem('rhymeSearchHistory'); updateHistoryUI(); } });

            dom.historyList.addEventListener('click', (e) => {
                const termSpan = e.target.closest('.history-term');
                const deleteBtn = e.target.closest('.history-delete');
                if (deleteBtn) { const termToDelete = deleteBtn.dataset.term; searchHistory = searchHistory.filter(t => t !== termToDelete); localStorage.setItem('rhymeSearchHistory', JSON.stringify(searchHistory)); updateHistoryUI(); return; }
                if (termSpan) { dom.searchInput.value = termSpan.textContent; performRhymeSearch(); }
            });

            dom.resultsSection.addEventListener('click', e => {
                const wordChip = e.target.closest('.word-chip');
                if (wordChip) openDetailModal(wordChip.dataset.word, 'word');
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeAllModals();
            });

            initialize();
        });
    </script>
</body>
</html>