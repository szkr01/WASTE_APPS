<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhyme Finder Pro | 日本語押韻検索</title>
    <meta name="description" content="Find rhyming Japanese words with an improved, efficient single-page interface. Explore words with the same vowel endings using our interactive rhyme dictionary with wildcard support.">
    <meta name="page:icon" content="fas fa-wave-square">
    <meta name="page:color" content="#38bdf8">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Roboto+Mono:wght@400;500&display=swap');
        
        body {
            font-family: 'Noto Sans JP', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 #f1f5f9;
        }

        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 10px;
            border: 2px solid #f1f5f9;
        }

        .loader {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            display: inline-block;
            position: relative;
            border: 3px solid;
            border-color: #d1d5db #d1d5db transparent transparent;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        .loader::after,
        .loader::before {
            content: '';  
            box-sizing: border-box;
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            margin: auto;
            border: 3px solid;
            border-color: transparent transparent #38bdf8 #38bdf8;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            box-sizing: border-box;
            animation: rotationBack 0.5s linear infinite;
            transform-origin: center center;
        }
        .loader::before {
            width: 28px;
            height: 28px;
            border-color: #d1d5db #d1d5db transparent transparent;
            animation: rotation 1.5s linear infinite;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        } 
        @keyframes rotationBack {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(-360deg); }
        }

        .stagger-card {
            transform: translateY(30px);
            opacity: 0;
            animation: slide-up-fade-in 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        @keyframes slide-up-fade-in {
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .tooltip-arrow::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 6px 6px 6px;
            border-color: transparent transparent #e5e7eb transparent;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-800">

    <div id="loading-overlay" class="fixed inset-0 bg-white/80 backdrop-blur-sm flex flex-col justify-center items-center z-50 transition-opacity duration-500">
        <div class="loader"></div>
        <p id="loading-text" class="mt-6 text-gray-700 font-medium text-lg">辞書データを準備しています...</p>
        <div class="w-64 bg-gray-200 rounded-full h-2 mt-4 overflow-hidden">
            <div id="loading-progress" class="bg-sky-400 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
    </div>

    <div id="app-container" class="grid grid-cols-1 md:grid-cols-12 min-h-screen opacity-0 transition-opacity duration-500">
        <aside class="md:col-span-4 lg:col-span-3 xl:col-span-3 bg-white border-r border-gray-200 p-6 flex flex-col h-screen">
            <header class="mb-6">
                <div class="flex items-center space-x-3">
                    <i class="fas fa-wave-square text-3xl text-sky-400"></i>
                    <h1 class="text-2xl font-bold text-gray-900">Rhyme Finder</h1>
                </div>
                <p class="mt-1 text-sm text-gray-500">日本語の押韻（韻）を探すツール</p>
            </header>

            <div class="relative group mb-4">
                <label for="searchInput" class="sr-only">検索する単語</label>
                <input type="text" id="searchInput" placeholder="例: 簡単, a?an" class="w-full pl-10 pr-20 py-3 text-base bg-gray-100 border-2 border-transparent rounded-lg focus:ring-2 focus:ring-sky-300 focus:bg-white focus:border-sky-400 outline-none transition-all duration-300">
                <i class="fas fa-search text-gray-400 absolute left-4 top-1/2 -translate-y-1/2"></i>
                <div class="absolute right-12 top-1/2 -translate-y-1/2">
                    <i class="fas fa-question-circle text-gray-400 peer cursor-help"></i>
                    <div class="invisible peer-hover:visible absolute z-10 w-64 p-3 text-sm font-light text-gray-600 bg-white rounded-lg border border-gray-200 shadow-lg bottom-full mb-2 left-1/2 -translate-x-1/2" role="tooltip">
                        <p class="font-sans">単語または母音 (<b class="font-mono text-gray-800">a,i,u,e,o,n</b>) で検索できます。<br>
                        <code class="font-mono bg-gray-100 text-xs py-0.5 px-1 rounded">?</code> をワイルドカードとして使うと、任意の1母音に一致します。</p>
                        <div class="tooltip-arrow border-gray-200"></div>
                    </div>
                </div>
                <button id="searchButton" class="absolute inset-y-0 right-0 flex items-center justify-center w-12 text-gray-500 hover:text-sky-500 transition-colors">
                    <i class="fas fa-arrow-right"></i>
                </button>
            </div>
            
            <div class="mb-6 border-t border-b border-gray-200 py-4">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-sm font-bold text-gray-500 uppercase tracking-wider">辞書フィルター</h2>
                    <div class="space-x-2">
                        <button id="filter-select-all" class="text-xs text-sky-600 hover:text-sky-800 font-medium">全選択</button>
                        <button id="filter-deselect-all" class="text-xs text-gray-500 hover:text-gray-800 font-medium">全解除</button>
                    </div>
                </div>
                <div id="dictionary-filter-list" class="flex flex-wrap gap-2">
                </div>
            </div>

            <div class="flex-grow flex flex-col min-h-0">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-sm font-bold text-gray-500 uppercase tracking-wider">検索履歴</h2>
                    <button id="clearHistoryButton" class="text-xs text-gray-400 hover:text-red-500 transition-colors" title="履歴を消去">
                        <i class="fas fa-trash-alt mr-1"></i>消去
                    </button>
                </div>
                <ul id="historyList" class="flex-grow space-y-1 overflow-y-auto pr-1">
                </ul>
            </div>

            <footer class="text-center mt-6 text-gray-400 text-xs">
                <p>© 2024 Rhyme Finder Pro</p>
            </footer>
        </aside>

        <main class="md:col-span-8 lg:col-span-9 xl:col-span-9 bg-gray-50 p-4 md:p-8 flex flex-col h-screen">
            <div id="results-header" class="hidden mb-4 p-4 bg-white rounded-lg border border-gray-200 flex flex-col sm:flex-row justify-between items-center gap-4">
                <p id="results-summary" class="text-gray-700 text-center sm:text-left">
                </p>
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-2">
                        <label for="sort-select" class="text-sm text-gray-600 shrink-0">並び順:</label>
                        <select id="sort-select" class="text-sm bg-gray-100 border-gray-300 rounded-md py-1 px-2 focus:ring-sky-300 focus:border-sky-300">
                            <option value="count">単語数</option>
                            <option value="vowel_len_asc">文字数 (昇順)</option>
                            <option value="vowel_len_desc">文字数 (降順)</option>
                        </select>
                    </div>
                    <div class="flex items-center space-x-2">
                        <label for="limit-select" class="text-sm text-gray-600 shrink-0">表示件数:</label>
                        <input type="number" id="limit-select" value="20" min="1" max="500" class="w-20 text-sm bg-gray-100 border-gray-300 rounded-md py-1 px-2 focus:ring-sky-300 focus:border-sky-300">
                    </div>
                </div>
            </div>

            <div id="results-section" class="flex-grow overflow-y-auto pr-2">
                <div id="welcome-message" class="flex flex-col items-center justify-center h-full text-center bg-white rounded-lg border-2 border-dashed border-gray-300 p-8">
                    <i class="fas fa-keyboard text-5xl text-gray-300 mb-6"></i>
                    <h2 class="text-2xl font-bold text-gray-700">ようこそ</h2>
                    <p class="mt-2 max-w-md text-gray-500">左のパネルで単語や母音列を入力して検索を開始してください。ワイルドカード(<code class="font-mono bg-gray-200 text-xs py-0.5 px-1 rounded">?</code>)も使えます。</p>
                </div>
            </div>
        </main>
    </div>

    <div id="word-detail-modal" class="fixed inset-0 bg-gray-900 bg-opacity-60 backdrop-blur-sm flex justify-center items-center p-4 z-50 opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out">
        <div id="modal-panel" class="bg-white rounded-2xl shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col transform opacity-0 scale-95 transition-all duration-300 ease-in-out">
            <div class="flex justify-between items-center p-5 border-b border-gray-200">
                <h2 id="modal-title" class="text-2xl font-bold text-gray-800"></h2>
                <button id="modal-close-btn" class="text-gray-400 hover:text-gray-700 hover:bg-gray-100 rounded-full w-9 h-9 flex items-center justify-center transition-colors">
                    <i class="fas fa-times text-lg"></i>
                </button>
            </div>
            <div id="modal-content" class="p-6 flex-grow overflow-y-auto space-y-4 bg-gray-50">
            </div>
            <div class="p-4 bg-white border-t border-gray-200 rounded-b-2xl text-right">
                 <button id="modal-close-btn-footer" class="bg-gray-200 text-gray-700 font-medium py-2 px-5 rounded-lg hover:bg-gray-300 transition-colors">
                    閉じる
                </button>
            </div>
        </div>
    </div>

    <script>
        class PrefixTree {
            constructor() {
                this.root = new Node();
            }
            add(word, wordObject) {
                let node = this.root;
                for (let i = 0; i < word.length; i++) {
                    let c = word[i];
                    if (!node.children[c]) {
                        node.children[c] = new Node();
                    }
                    node = node.children[c];
                }
                word = word.split('').reverse().join('');
                node.values.add(wordObject);
                node.vowel = word;
            }
            searchAll(word) {
                let node = this.root;
                for (let i = 0; i < word.length; i++) {
                    let c = word[i];
                    if (!node.children[c]) {
                        return [];
                    }
                    node = node.children[c];
                }
                return this._searchAll(node);
            }
            _searchAll(node) {
                let res = [];
                if (node.values.size > 0) {
                    res.push({
                        vowel: node.vowel,
                        set: node.values
                    });
                }
                for (let c in node.children) {
                    res = res.concat(this._searchAll(node.children[c]));
                }
                return res;
            }
            searchWithWildcard(pattern) {
                const results = this._searchWithWildcardRecursive(this.root, pattern);
                return this.mergeResults(results);
            }
            _searchWithWildcardRecursive(node, subpattern) {
                if (!node) return [];
                if (subpattern.length === 0) {
                    return this._searchAll(node);
                }

                const char = subpattern[0];
                const remainingPattern = subpattern.substring(1);
                let results = [];

                if (char === '?') {
                    const wildcards = ['a', 'i', 'u', 'e', 'o', 'n'];
                    for (const wc of wildcards) {
                        if (node.children[wc]) {
                            results.push(...this._searchWithWildcardRecursive(node.children[wc], remainingPattern));
                        }
                    }
                } else {
                    if (node.children[char]) {
                        results.push(...this._searchWithWildcardRecursive(node.children[char], remainingPattern));
                    }
                }
                return results;
            }
            mergeResults(results) {
                const merged = new Map();
                for (const result of results) {
                    const currentSet = merged.get(result.vowel);
                    if (currentSet) {
                        for (const wordObj of result.set) {
                            currentSet.add(wordObj);
                        }
                    } else {
                        merged.set(result.vowel, new Set(result.set));
                    }
                }
                return Array.from(merged.entries()).map(([vowel, set]) => ({ vowel, set }));
            }
        }

        class Node {
            constructor() {
                this.children = {};
                this.values = new Set();
                this.vowel = null;
            }
        }
        
        class YomiUtil {
             constructor() {
                this.roma_to_hira = { "a": "あ", "ba": "ば", "be": "べ", "bi": "び", "bo": "ぼ", "bu": "ぶ", "bya": "びゃ", "bye": "びぇ", "byi": "びぃ", "byo": "びょ", "byu": "びゅ", "ca": "か", "ce": "せ", "cha": "ちゃ", "che": "ちぇ", "chi": "ち", "cho": "ちょ", "chu": "ちゅ", "ci": "し", "co": "こ", "cu": "く", "cya": "ちゃ", "cye": "ちぇ", "cyi": "ちぃ", "cyo": "ちょ", "cyu": "ちゅ", "da": "だ", "de": "で", "dha": "でゃ", "dhe": "でぇ", "dhi": "でぃ", "dho": "でょ", "dhu": "でゅ", "di": "ぢ", "do": "ど", "du": "づ", "dwa": "どぁ", "dwe": "どぇ", "dwi": "どぃ", "dwo": "どぉ", "dwu": "どぅ", "dya": "ぢゃ", "dye": "ぢぇ", "dyi": "ぢぃ", "dyo": "ぢょ", "dyu": "ぢゅ", "e": "え", "fa": "ふぁ", "fe": "ふぇ", "fi": "ふぃ", "fo": "ふぉ", "fu": "ふ", "fwa": "ふぁ", "fwe": "ふぇ", "fwi": "ふぃ", "fwo": "ふぉ", "fwu": "ふぅ", "fya": "ふゃ", "fye": "ふぇ", "fyi": "ふぃ", "fyo": "ふょ", "fyu": "ふゅ", "ga": "が", "ge": "げ", "gi": "ぎ", "go": "ご", "gu": "ぐ", "gwa": "ぐぁ", "gwe": "ぐぇ", "gwi": "ぐぃ", "gwo": "ぐぉ", "gwu": "ぐぅ", "gya": "ぎゃ", "gye": "ぎぇ", "gyi": "ぎぃ", "gyo": "ぎょ", "gyu": "ぎゅ", "ha": "は", "he": "へ", "hi": "ひ", "ho": "ほ", "hu": "ふ", "hya": "ひゃ", "hye": "ひぇ", "hyi": "ひぃ", "hyo": "ひょ", "hyu": "ひゅ", "i": "い", "ja": "じゃ", "je": "じぇ", "ji": "じ", "jo": "じょ", "ju": "じゅ", "jya": "じゃ", "jye": "じぇ", "jyi": "じぃ", "jyo": "じょ", "jyu": "じゅ", "ka": "か", "ke": "け", "ki": "き", "ko": "こ", "ku": "く", "kwa": "くぁ", "kya": "きゃ", "kye": "きぇ", "kyi": "きぃ", "kyo": "きょ", "kyu": "きゅ", "la": "ぁ", "le": "ぇ", "li": "ぃ", "lka": "ヵ", "lke": "ヶ", "lo": "ぉ", "lu": "ぅ", "lwa": "ゎ", "lya": "ゃ", "lye": "ぇ", "lyi": "ぃ", "lyo": "ょ", "lyu": "ゅ", "ma": "ま", "me": "め", "mi": "み", "mo": "も", "mu": "む", "mya": "みゃ", "mye": "みぇ", "myi": "みぃ", "myo": "みょ", "myu": "みゅ", "n": "ん", "na": "な", "ne": "ね", "ni": "に", "nn": "ん", "no": "の", "nu": "ぬ", "nya": "にゃ", "nye": "にぇ", "nyi": "にぃ", "nyo": "にょ", "nyu": "にゅ", "o": "お", "pa": "ぱ", "pe": "ぺ", "pi": "ぴ", "po": "ぽ", "pu": "ぷ", "pya": "ぴゃ", "pye": "ぴぇ", "pyi": "ぴぃ", "pyo": "ぴょ", "pyu": "ぴゅ", "qa": "くぁ", "qe": "くぇ", "qi": "くぃ", "qo": "くぉ", "qu": "く", "qwa": "くぁ", "qwe": "くぇ", "qwi": "くぃ", "qwo": "くぉ", "qwu": "くぅ", "qya": "くゃ", "qye": "くぇ", "qyi": "くぃ", "qyo": "くょ", "qyu": "くゅ", "ra": "ら", "re": "れ", "ri": "り", "ro": "ろ", "ru": "る", "rya": "りゃ", "rye": "りぇ", "ryi": "りぃ", "ryo": "りょ", "ryu": "りゅ", "sa": "さ", "se": "せ", "sha": "しゃ", "she": "しぇ", "shi": "し", "sho": "しょ", "shu": "しゅ", "si": "し", "so": "そ", "su": "す", "swa": "すぁ", "swe": "すぇ", "swi": "すぃ", "swo": "すぉ", "swu": "すぅ", "sya": "しゃ", "sye": "しぇ", "syi": "しぃ", "syo": "しょ", "syu": "しゅ", "ta": "た", "te": "て", "tha": "てゃ", "the": "てぇ", "thi": "てぃ", "tho": "てょ", "thu": "てゅ", "ti": "ち", "to": "と", "tsa": "つぁ", "tse": "つぇ", "tsi": "つぃ", "tso": "つぉ", "tsu": "つ", "tu": "つ", "twa": "とぁ", "twe": "とぇ", "twi": "とぃ", "two": "とぉ", "twu": "とぅ", "tya": "ちゃ", "tye": "ちぇ", "tyi": "ちぃ", "tyo": "ちょ", "tyu": "ちゅ", "u": "う", "va": "ヴぁ", "ve": "ヴぇ", "vi": "ヴぃ", "vo": "ヴぉ", "vu": "ヴ", "vya": "ヴゃ", "vye": "ヴぇ", "vyi": "ヴぃ", "vyo": "ヴょ", "vyu": "ヴゅ", "wa": "わ", "we": "うぇ", "wha": "うぁ", "whe": "うぇ", "whi": "うぃ", "who": "うぉ", "whu": "う", "wi": "うぃ", "wo": "を", "wu": "う", "wye": "ゑ", "wyi": "ゐ", "xa": "ぁ", "xe": "ぇ", "xi": "ぃ", "xka": "ヵ", "xke": "ヶ", "xo": "ぉ", "xu": "ぅ", "xwa": "ゎ", "xya": "ゃ", "xye": "ぇ", "xyi": "ぃ", "xyo": "ょ", "xyu": "ゅ", "ya": "や", "ye": "いぇ", "yi": "い", "yo": "よ", "yu": "ゆ", "za": "ざ", "ze": "ぜ", "zi": "じ", "zo": "ぞ", "zu": "ず", "zya": "じゃ", "zye": "じぇ", "zyi": "じぃ", "zyo": "じょ", "zyu": "じゅ", }
                this.kana_to_roma = {};
                for (let roma in this.roma_to_hira) {
                    let hira = this.roma_to_hira[roma];
                    let kana = this.hira2kana(hira);
                    if (this.kana_to_roma[kana]) continue;
                    this.kana_to_roma[kana] = roma;
                }
            }
            hira2kana(str) {
                return str.replace(/[\u3041-\u3096]/g, match => String.fromCharCode(match.charCodeAt(0) + 0x60));
            }
            kana2roma(str) {
                const res = [];
                let i = 0;
                while (i < str.length) {
                    let c = str[i];
                    if (i + 1 < str.length) {
                        let cc = c + str[i + 1];
                        if (this.kana_to_roma[cc]) {
                            res.push(this.kana_to_roma[cc]);
                            i += 2;
                            continue;
                        }
                    }
                    if (this.kana_to_roma[c]) {
                        res.push(this.kana_to_roma[c]);
                    }
                    i++;
                }
                return res;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const dom = {
                loadingOverlay: document.getElementById('loading-overlay'),
                loadingText: document.getElementById('loading-text'),
                loadingProgress: document.getElementById('loading-progress'),
                appContainer: document.getElementById('app-container'),
                searchInput: document.getElementById('searchInput'),
                searchButton: document.getElementById('searchButton'),
                historyList: document.getElementById('historyList'),
                clearHistoryButton: document.getElementById('clearHistoryButton'),
                resultsHeader: document.getElementById('results-header'),
                resultsSummary: document.getElementById('results-summary'),
                resultsSection: document.getElementById('results-section'),
                welcomeMessage: document.getElementById('welcome-message'),
                sortSelect: document.getElementById('sort-select'),
                limitSelect: document.getElementById('limit-select'),
                dictionaryFilterList: document.getElementById('dictionary-filter-list'),
                filterSelectAll: document.getElementById('filter-select-all'),
                filterDeselectAll: document.getElementById('filter-deselect-all'),
                wordDetailModal: document.getElementById('word-detail-modal'),
                modalPanel: document.getElementById('modal-panel'),
                modalTitle: document.getElementById('modal-title'),
                modalContent: document.getElementById('modal-content'),
                modalCloseBtn: document.getElementById('modal-close-btn'),
                modalCloseBtnFooter: document.getElementById('modal-close-btn-footer'),
            };

            const YU = new YomiUtil();
            const pt = new PrefixTree();
            const wordToReadingMap = new Map();
            const wordDetailsMap = new Map();
            let searchHistory = JSON.parse(localStorage.getItem('rhymeSearchHistory')) || [];
            let currentResults = [];

            const csvList = [
                "../Assets/ipac/Adj.csv", "../Assets/ipac/Adnominal.csv", "../Assets/ipac/Adverb.csv", "../Assets/ipac/Auxil.csv",
                "../Assets/ipac/Conjunction.csv", "../Assets/ipac/Filler.csv", "../Assets/ipac/Interjection.csv",
                "../Assets/ipac/Noun.adjv.csv", "../Assets/ipac/Noun.adverbal.csv", "../Assets/ipac/Noun.csv",
                "../Assets/ipac/Noun.demonst.csv", "../Assets/ipac/Noun.nai.csv", "../Assets/ipac/Noun.name.csv",
                "../Assets/ipac/Noun.number.csv", "../Assets/ipac/Noun.org.csv", "../Assets/ipac/Noun.others.csv",
                "../Assets/ipac/Noun.place.csv", "../Assets/ipac/Noun.proper.csv", "../Assets/ipac/Noun.verbal.csv",
                "../Assets/ipac/Others.csv", "../Assets/ipac/Postp-col.csv", "../Assets/ipac/Postp.csv",
                "../Assets/ipac/Prefix.csv", "../Assets/ipac/Suffix.csv", "../Assets/ipac/Symbol.csv", "../Assets/ipac/Verb.csv"
            ];
            
            const dictionaryConfig = {
                'Noun': { name: '名詞', color: 'blue' }, 'Verb': { name: '動詞', color: 'green' }, 'Adj': { name: '形容詞', color: 'pink' }, 'Adverb': { name: '副詞', color: 'purple' }, 'Adnominal': { name: '連体詞', color: 'fuchsia' }, 'Conjunction': { name: '接続詞', color: 'indigo' }, 'Interjection': { name: '感動詞', color: 'yellow' }, 'Postp': { name: '助詞', color: 'cyan' }, 'Auxil': { name: '助動詞', color: 'violet' }, 'Prefix': { name: '接頭辞', color: 'emerald' }, 'Suffix': { name: '接尾辞', color: 'lime' }, 'Symbol': { name: '記号', color: 'orange' }, 'Filler': { name: 'フィラー', color: 'gray' }, 'Others': { name: 'その他', color: 'slate' }
            };

            function getTailwindColorClasses(source) {
                const color = dictionaryConfig[source]?.color || 'gray';
                const classMap = { 'pink': 'bg-pink-100 text-pink-800 hover:bg-pink-200 hover:border-pink-400', 'fuchsia': 'bg-fuchsia-100 text-fuchsia-800 hover:bg-fuchsia-200 hover:border-fuchsia-400', 'purple': 'bg-purple-100 text-purple-800 hover:bg-purple-200 hover:border-purple-400', 'violet': 'bg-violet-100 text-violet-800 hover:bg-violet-200 hover:border-violet-400', 'indigo': 'bg-indigo-100 text-indigo-800 hover:bg-indigo-200 hover:border-indigo-400', 'gray': 'bg-gray-100 text-gray-800 hover:bg-gray-200 hover:border-gray-400', 'yellow': 'bg-yellow-100 text-yellow-800 hover:bg-yellow-200 hover:border-yellow-400', 'blue': 'bg-blue-100 text-blue-800 hover:bg-blue-200 hover:border-blue-400', 'slate': 'bg-slate-100 text-slate-800 hover:bg-slate-200 hover:border-slate-400', 'cyan': 'bg-cyan-100 text-cyan-800 hover:bg-cyan-200 hover:border-cyan-400', 'emerald': 'bg-emerald-100 text-emerald-800 hover:bg-emerald-200 hover:border-emerald-400', 'lime': 'bg-lime-100 text-lime-800 hover:bg-lime-200 hover:border-lime-400', 'orange': 'bg-orange-100 text-orange-800 hover:bg-orange-200 hover:border-orange-400', 'green': 'bg-green-100 text-green-800 hover:bg-green-200 hover:border-green-400', };
                return classMap[color] || classMap['gray'];
            }
            
            function getTailwindFilterChipColors(color) {
                const sets = { 'pink':      { base: 'bg-white', text: 'text-pink-700',    border: 'border-pink-300',    hover: 'hover:bg-pink-50 hover:border-pink-400',    checked_bg: 'bg-pink-500',    checked_text: 'text-white', checked_border: 'border-pink-500' }, 'fuchsia':   { base: 'bg-white', text: 'text-fuchsia-700', border: 'border-fuchsia-300', hover: 'hover:bg-fuchsia-50 hover:border-fuchsia-400', checked_bg: 'bg-fuchsia-500', checked_text: 'text-white', checked_border: 'border-fuchsia-500' }, 'purple':    { base: 'bg-white', text: 'text-purple-700',  border: 'border-purple-300',  hover: 'hover:bg-purple-50 hover:border-purple-400',  checked_bg: 'bg-purple-500',  checked_text: 'text-white', checked_border: 'border-purple-500' }, 'violet':    { base: 'bg-white', text: 'text-violet-700',  border: 'border-violet-300',  hover: 'hover:bg-violet-50 hover:border-violet-400',  checked_bg: 'bg-violet-500',  checked_text: 'text-white', checked_border: 'border-violet-500' }, 'indigo':    { base: 'bg-white', text: 'text-indigo-700',  border: 'border-indigo-300',  hover: 'hover:bg-indigo-50 hover:border-indigo-400',  checked_bg: 'bg-indigo-500',  checked_text: 'text-white', checked_border: 'border-indigo-500' }, 'blue':      { base: 'bg-white', text: 'text-blue-700',    border: 'border-blue-300',    hover: 'hover:bg-blue-50 hover:border-blue-400',    checked_bg: 'bg-blue-500',    checked_text: 'text-white', checked_border: 'border-blue-500' }, 'cyan':      { base: 'bg-white', text: 'text-cyan-700',    border: 'border-cyan-300',    hover: 'hover:bg-cyan-50 hover:border-cyan-400',    checked_bg: 'bg-cyan-500',    checked_text: 'text-white', checked_border: 'border-cyan-500' }, 'green':     { base: 'bg-white', text: 'text-green-700',   border: 'border-green-300',   hover: 'hover:bg-green-50 hover:border-green-400',   checked_bg: 'bg-green-500',   checked_text: 'text-white', checked_border: 'border-green-500' }, 'lime':      { base: 'bg-white', text: 'text-lime-700',    border: 'border-lime-300',    hover: 'hover:bg-lime-50 hover:border-lime-400',    checked_bg: 'bg-lime-500',    checked_text: 'text-white', checked_border: 'border-lime-500' }, 'yellow':    { base: 'bg-white', text: 'text-yellow-700',  border: 'border-yellow-300',  hover: 'hover:bg-yellow-50 hover:border-yellow-400',  checked_bg: 'bg-yellow-500',  checked_text: 'text-white', checked_border: 'border-yellow-500' }, 'orange':    { base: 'bg-white', text: 'text-orange-700',  border: 'border-orange-300',  hover: 'hover:bg-orange-50 hover:border-orange-400',  checked_bg: 'bg-orange-500',  checked_text: 'text-white', checked_border: 'border-orange-500' }, 'slate':     { base: 'bg-white', text: 'text-slate-700',   border: 'border-slate-300',   hover: 'hover:bg-slate-50 hover:border-slate-400',   checked_bg: 'bg-slate-500',   checked_text: 'text-white', checked_border: 'border-slate-500' }, 'gray':      { base: 'bg-white', text: 'text-gray-700',    border: 'border-gray-300',    hover: 'hover:bg-gray-50 hover:border-gray-400',    checked_bg: 'bg-gray-500',    checked_text: 'text-white', checked_border: 'border-gray-500' }, };
                return sets[color] || sets['gray'];
            }

            function getTypeFromPath(path) {
                const fileName = path.split('/').pop();
                const baseType = fileName.split('.')[0];
                return dictionaryConfig[baseType] ? baseType : 'Others';
            }

            function getReversedVowelString(kanaString) {
                if (!kanaString) return '';
                const cleanKana = kanaString.replace(/ー/g, '');
                const romajiArray = YU.kana2roma(cleanKana);
                if (!romajiArray) return '';
                return romajiArray.map(e => e[e.length - 1]).reverse().join('');
            }

            async function initialize() {
                try {
                    let loadedCount = 0;
                    for (const csvPath of csvList) {
                        const response = await fetch(csvPath);
                        if (!response.ok) { 
                            console.warn(`Could not load ${csvPath}, skipping.`);
                            continue;
                        }
                        const data = await response.text();
                        const rows = data.trim().split('\n');
                        const source = getTypeFromPath(csvPath);

                        for (const line of rows) {
                            const row = line.split(',');
                            if (row && row.length > 11 && row[0] && row[11]) {
                                const surfaceWord = row[0];
                                const yomi = row[11];
                                
                                if (!wordDetailsMap.has(surfaceWord)) {
                                    wordDetailsMap.set(surfaceWord, []);
                                }
                                const detail = {
                                    surface: row[0] || '', pos1: row[4] || '*', pos2: row[5] || '*', pos3: row[6] || '*', pos4: row[7] || '*', conjForm: row[8] || '*', conjType: row[9] || '*', baseForm: row[10] || '*', yomi: row[11] || '', pronunciation: row[12] || '', source: source
                                };
                                wordDetailsMap.get(surfaceWord).push(detail);

                                if (!wordToReadingMap.has(surfaceWord)) wordToReadingMap.set(surfaceWord, { yomi, source });
                                const reversedVowels = getReversedVowelString(yomi);
                                if (reversedVowels) pt.add(reversedVowels, { word: surfaceWord, source });
                            }
                        }
                        loadedCount++;
                        const progress = (loadedCount / csvList.length) * 100;
                        dom.loadingProgress.style.width = `${progress}%`;
                        dom.loadingText.textContent = `辞書を処理中... (${loadedCount}/${csvList.length})`;
                    }
                    
                    setupFilters();
                    
                    dom.loadingOverlay.classList.add('opacity-0', 'pointer-events-none');
                    dom.appContainer.classList.remove('opacity-0');
                    dom.searchInput.focus();
                    updateHistoryUI();
                } catch (error) {
                    console.error('Initialization failed:', error);
                    dom.loadingText.innerHTML = `エラー: 辞書ファイルの読み込みに失敗しました。<br>ファイルが指定の場所にあるか確認してください。`;
                    dom.loadingText.classList.add('text-red-500');
                    dom.loadingProgress.parentElement.classList.add('hidden');
                }
            }
            
            function setupFilters() {
                dom.dictionaryFilterList.innerHTML = '';
                Object.entries(dictionaryConfig).forEach(([key, {name, color}]) => {
                    const colors = getTailwindFilterChipColors(color);
                    const label = document.createElement('label');
                    label.className = `cursor-pointer`;
                    label.innerHTML = `
                        <input type="checkbox" data-filter-type="${key}" class="filter-checkbox sr-only peer" checked>
                        <span class="peer-checked:${colors.checked_bg} peer-checked:${colors.checked_text} peer-checked:${colors.checked_border} ${colors.base} ${colors.text} ${colors.border} inline-block text-xs font-medium px-3 py-1.5 rounded-full border-2 transition-all duration-200 ${colors.hover}">
                            ${name}
                        </span>
                    `;
                    dom.dictionaryFilterList.appendChild(label);
                });
            }
            
            function updateHistoryUI() {
                dom.historyList.innerHTML = '';
                if (searchHistory.length === 0) {
                    dom.historyList.innerHTML = `<li class="text-center text-sm text-gray-400 px-3 py-2">履歴はありません</li>`;
                    dom.clearHistoryButton.classList.add('hidden');
                } else {
                    searchHistory.forEach(term => {
                        const li = document.createElement('li');
                        li.className = 'group flex justify-between items-center rounded-md hover:bg-gray-100 cursor-pointer text-gray-700';
                        li.innerHTML = `<span class="history-term flex-grow px-3 py-2">${term}</span>
                                        <button class="history-delete text-gray-400 hover:text-red-500 w-8 h-8 flex items-center justify-center rounded-full opacity-0 group-hover:opacity-100 transition-opacity" data-term="${term}"><i class="fas fa-times"></i></button>`;
                        dom.historyList.appendChild(li);
                    });
                    dom.clearHistoryButton.classList.remove('hidden');
                }
            }

            function addToHistory(term) {
                if (!term) return;
                searchHistory = searchHistory.filter(t => t.toLowerCase() !== term.toLowerCase());
                searchHistory.unshift(term);
                if (searchHistory.length > 20) searchHistory.pop();
                localStorage.setItem('rhymeSearchHistory', JSON.stringify(searchHistory));
                updateHistoryUI();
            }
            
            function runFilterAndSort() {
                const query = dom.searchInput.value.trim();
                if (!query || currentResults.length === 0) return;
                const isVowelQuery = /^[aiueon?]+$/i.test(query);
                displayResults(query, isVowelQuery);
            }

            function displayResults(query, isVowelSearch = false) {
                const activeFilters = new Set(Array.from(document.querySelectorAll('.filter-checkbox:checked')).map(cb => cb.dataset.filterType));
                
                let filteredResults = currentResults.map(group => ({
                    ...group,
                    set: new Set(Array.from(group.set).filter(wordObj => activeFilters.has(wordObj.source)))
                })).filter(group => group.set.size > 0);
                
                const sortType = dom.sortSelect.value;
                if (sortType === 'vowel_len_desc') {
                    filteredResults.sort((a, b) => b.vowel.length - a.vowel.length || b.set.size - a.set.size);
                } else if (sortType === 'vowel_len_asc') {
                    filteredResults.sort((a, b) => a.vowel.length - b.vowel.length || b.set.size - a.set.size);
                } else if (sortType === 'count') {
                    filteredResults.sort((a, b) => b.set.size - a.set.size || b.vowel.length - a.vowel.length);
                }
                
                const limit = parseInt(dom.limitSelect.value, 10) || 50;
                const limitedResults = filteredResults.slice(0, limit);
                
                dom.resultsSection.innerHTML = '';
                dom.welcomeMessage.classList.add('hidden');

                let summaryText;
                if (isVowelSearch) {
                    summaryText = `母音: <span class="font-bold text-sky-500 font-mono">${query}</span>`;
                } else {
                    const readingInfo = wordToReadingMap.get(query);
                    const readingVowels = readingInfo ? getReversedVowelString(readingInfo.yomi).split('').reverse().join('') : '不明';
                    summaryText = `「<span class="font-bold text-sky-500">${query}</span>」 (母音: <span class="font-mono">${readingVowels}</span>)`;
                }

                if (limitedResults.length === 0) {
                    dom.resultsHeader.classList.remove('hidden');
                    dom.resultsSummary.innerHTML = `${summaryText} に一致する単語は見つかりませんでした。`;
                    dom.resultsSection.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-center bg-white rounded-lg border-2 border-dashed border-gray-300 p-8">
                        <i class="fas fa-search-minus text-5xl text-gray-300 mb-6"></i>
                        <h2 class="text-2xl font-bold text-gray-700">結果なし</h2>
                        <p class="mt-2 max-w-md text-gray-500">別の単語で試すか、フィルター設定を確認してください。</p>
                    </div>`;
                    return;
                }

                dom.resultsHeader.classList.remove('hidden');
                const totalWords = filteredResults.reduce((acc, r) => acc + r.set.size, 0);
                dom.resultsSummary.innerHTML = `${summaryText} の検索結果: <span class="font-bold">${totalWords}</span>語（上位${limitedResults.length}件を表示）`;

                limitedResults.forEach((result, index) => {
                    const card = document.createElement('div');
                    card.className = 'stagger-card bg-white border border-gray-200 rounded-xl p-6 mb-4';
                    card.style.animationDelay = `${index * 50}ms`;
                    
                    const vowelSequence = result.vowel.split('').map(v => `<span class="font-mono">${v}</span>`).join('<span class="text-gray-300 mx-px">·</span>');
                    
                    const words = Array.from(result.set).sort((a, b) => a.word.localeCompare(b.word, 'ja'));
                    const wordChips = words.map(wordObj => {
                        const colorClasses = getTailwindColorClasses(wordObj.source);
                        return `<button data-word="${wordObj.word}" class="word-chip ${colorClasses} font-medium py-1.5 px-3 rounded-full border border-transparent text-sm hover:shadow-md transition-all cursor-pointer" title="${dictionaryConfig[wordObj.source]?.name || ''}">${wordObj.word}</button>`
                    }).join('');

                    card.innerHTML = `
                        <div class="flex justify-between items-center mb-4 pb-3 border-b border-gray-200">
                            <h3 class="text-lg font-bold text-sky-600 flex items-center gap-3">
                                <i class="fas fa-signature text-sky-400"></i>
                                母音: <span class="text-gray-800">${vowelSequence}</span>
                            </h3>
                            <span class="text-sm font-medium bg-sky-100 text-sky-700 py-1 px-3 rounded-full">${words.length}語</span>
                        </div>
                        <div class="flex flex-wrap gap-2">${wordChips}</div>`;
                    dom.resultsSection.appendChild(card);
                });
            }

            function performSearch() {
                const query = dom.searchInput.value.trim();
                if (!query) return;

                const originalSearchButtonIcon = dom.searchButton.innerHTML;
                dom.searchButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;
                dom.searchButton.disabled = true;

                setTimeout(() => {
                    const isVowelQuery = /^[aiueon?]+$/i.test(query);
                    const lowerQuery = query.toLowerCase();

                    if (isVowelQuery) {
                        const reversedPattern = lowerQuery.split('').reverse().join('');
                        if (lowerQuery.includes('?')) {
                            currentResults = pt.searchWithWildcard(reversedPattern);
                        } else {
                            currentResults = pt.searchAll(reversedPattern);
                        }
                    } else {
                        let readingInfo = wordToReadingMap.get(query);
                        let reading = readingInfo ? readingInfo.yomi : YU.hira2kana(query);
                        const reversedVowelsForSearch = getReversedVowelString(reading);
                        currentResults = reversedVowelsForSearch ? pt.searchAll(reversedVowelsForSearch) : [];
                    }

                    displayResults(query, isVowelQuery);
                    addToHistory(query);
                    dom.searchButton.innerHTML = originalSearchButtonIcon;
                    dom.searchButton.disabled = false;
                }, 100); 
            }

            function openWordDetailModal(word) {
                const details = wordDetailsMap.get(word);
                if (!details || details.length === 0) { return; }

                dom.modalTitle.textContent = word;
                dom.modalContent.innerHTML = '';

                details.forEach((detail, index) => {
                    const pos = [detail.pos1, detail.pos2, detail.pos3, detail.pos4].filter(p => p && p !== '*' && p !== '').join(' - ');
                    const { name, color } = dictionaryConfig[detail.source] || { name: '不明', color: 'gray' };
                    const colors = getTailwindFilterChipColors(color);
                    
                    const detailCard = document.createElement('div');
                    detailCard.className = 'bg-white border border-gray-200 rounded-lg p-4';
                    
                    detailCard.innerHTML = `
                        <div class="flex justify-between items-start mb-3">
                            <h4 class="font-bold text-gray-700">エントリー ${index + 1}</h4>
                            <span class="${colors.checked_bg} ${colors.checked_text} text-xs font-bold px-3 py-1 rounded-full">${name}</span>
                        </div>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-3 text-sm">
                            <div class="flex flex-col"><span class="text-xs text-gray-500 font-semibold">読み</span><span class="text-gray-800 font-mono">${detail.yomi || 'N/A'}</span></div>
                            <div class="flex flex-col"><span class="text-xs text-gray-500 font-semibold">発音</span><span class="text-gray-800 font-mono">${detail.pronunciation || 'N/A'}</span></div>
                            <div class="flex flex-col"><span class="text-xs text-gray-500 font-semibold">原形</span><span class="text-gray-800">${detail.baseForm === '*' ? detail.surface : detail.baseForm}</span></div>
                            <div class="flex flex-col col-span-1 sm:col-span-2"><span class="text-xs text-gray-500 font-semibold">品詞</span><span class="text-gray-800">${pos || 'N/A'}</span></div>
                            <div class="flex flex-col"><span class="text-xs text-gray-500 font-semibold">活用形</span><span class="text-gray-800">${detail.conjForm === '*' ? 'N/A' : detail.conjForm}</span></div>
                            <div class="flex flex-col"><span class="text-xs text-gray-500 font-semibold">活用型</span><span class="text-gray-800">${detail.conjType === '*' ? 'N/A' : detail.conjType}</span></div>
                        </div>
                    `;
                    dom.modalContent.appendChild(detailCard);
                });

                document.body.classList.add('overflow-hidden');
                dom.wordDetailModal.classList.remove('opacity-0', 'pointer-events-none');
                requestAnimationFrame(() => {
                    dom.modalPanel.classList.remove('opacity-0', 'scale-95');
                });
            }

            function closeWordDetailModal() {
                dom.modalPanel.classList.add('opacity-0', 'scale-95');
                dom.wordDetailModal.classList.add('opacity-0');
                
                setTimeout(() => {
                    dom.wordDetailModal.classList.add('pointer-events-none');
                    document.body.classList.remove('overflow-hidden');
                }, 300);
            }
            
            dom.searchButton.addEventListener('click', performSearch);
            dom.searchInput.addEventListener('keydown', (e) => e.key === 'Enter' && performSearch());
            
            dom.sortSelect.addEventListener('change', runFilterAndSort);
            dom.limitSelect.addEventListener('change', runFilterAndSort);
            dom.dictionaryFilterList.addEventListener('change', runFilterAndSort);
            
            dom.filterSelectAll.addEventListener('click', () => {
                document.querySelectorAll('.filter-checkbox').forEach(cb => cb.checked = true);
                runFilterAndSort();
            });
            dom.filterDeselectAll.addEventListener('click', () => {
                document.querySelectorAll('.filter-checkbox').forEach(cb => cb.checked = false);
                runFilterAndSort();
            });
            
            dom.clearHistoryButton.addEventListener('click', () => {
                if (confirm('検索履歴をすべて消去しますか？')) {
                    searchHistory = [];
                    localStorage.removeItem('rhymeSearchHistory');
                    updateHistoryUI();
                }
            });

            dom.historyList.addEventListener('click', (e) => {
                const termSpan = e.target.closest('.history-term');
                const deleteBtn = e.target.closest('.history-delete');
                
                if (deleteBtn) {
                    const termToDelete = deleteBtn.dataset.term;
                    searchHistory = searchHistory.filter(t => t !== termToDelete);
                    localStorage.setItem('rhymeSearchHistory', JSON.stringify(searchHistory));
                    updateHistoryUI();
                    return;
                }
                
                if (termSpan) {
                    dom.searchInput.value = termSpan.textContent;
                    performSearch();
                }
            });

            dom.resultsSection.addEventListener('click', e => {
                const wordChip = e.target.closest('.word-chip');
                if (wordChip) {
                    openWordDetailModal(wordChip.dataset.word);
                }
            });

            dom.modalCloseBtn.addEventListener('click', closeWordDetailModal);
            dom.modalCloseBtnFooter.addEventListener('click', closeWordDetailModal);
            dom.wordDetailModal.addEventListener('click', (e) => {
                if (e.target === dom.wordDetailModal) {
                    closeWordDetailModal();
                }
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !dom.wordDetailModal.classList.contains('pointer-events-none')) {
                    closeWordDetailModal();
                }
            });

            initialize();
        });
    </script>
</body>
</html>