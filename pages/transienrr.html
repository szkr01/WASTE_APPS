<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebula Weaver</title>
    <meta name="description" content="An interactive WebGL shader ported from GLSL, creating a dynamic, fiery nebula visualization. Control FFT simulation and global parameters in real-time.">
    <meta name="page:icon" content="fas fa-atom">
    <meta name="page:color" content="#38bdf8">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3c3c3c;
            --text-primary: #d4d4d4;
            --text-secondary: #a0a0a0;
            --accent: #38bdf8;
            --accent-dark: #0e7490;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        #gl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .ui-panel {
            background-color: var(--bg-secondary);
            border: 1px solid var(--bg-tertiary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 120px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 150%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip .tooltip-text-left {
             bottom: 5px;
             left: 125%;
             margin-left: 0;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type="range"]:focus {
            outline: none;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: var(--bg-tertiary);
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            margin-top: -6px;
            border: 2px solid var(--bg-secondary);
            transition: background 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        
        input[type="range"]:active::-webkit-slider-thumb {
            background: #fff;
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: var(--bg-tertiary);
            border-radius: 5px;
        }

        input[type="range"]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: 2px solid var(--bg-secondary);
        }
        
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

    </style>
</head>
<body class="w-screen h-screen m-0 p-0">

    <canvas id="gl-canvas"></canvas>

    <header class="fixed top-0 left-0 w-full h-12 flex items-center justify-between px-4 ui-panel z-20" style="background-color: var(--bg-secondary); border-width: 0 0 1px 0;">
        <div class="flex items-center gap-3">
            <i class="fas fa-atom text-xl text-sky-400"></i>
            <h1 class="text-lg font-semibold text-gray-200">Nebula Weaver</h1>
        </div>
        <div id="info-display" class="absolute left-1/2 -translate-x-1/2 text-sm text-gray-400">
            <span id="fps-display">FPS: --</span>
        </div>
        <div class="flex items-center gap-4">
            <button id="reset-button" class="text-gray-400 hover:text-white transition-colors duration-200 tooltip">
                <i class="fas fa-sync-alt"></i>
                <span class="tooltip-text">Reset Controls</span>
            </button>
            <button id="fullscreen-button" class="text-gray-400 hover:text-white transition-colors duration-200 tooltip">
                <i class="fas fa-expand"></i>
                <span class="tooltip-text">Toggle Fullscreen</span>
            </button>
        </div>
    </header>

    <aside class="fixed right-0 top-12 bottom-0 w-80 p-4 space-y-6 ui-panel overflow-y-auto">
        <div class="space-y-4">
            <h2 class="text-sm font-bold uppercase tracking-wider border-b border-gray-600 pb-2 text-gray-400">
                <i class="fas fa-wave-square mr-2 text-sky-400"></i>
                FFT Simulation
            </h2>
            <div id="fft-controls" class="space-y-4"></div>
        </div>
        
        <div class="space-y-4">
            <h2 class="text-sm font-bold uppercase tracking-wider border-b border-gray-600 pb-2 text-gray-400">
                <i class="fas fa-globe-americas mr-2 text-sky-400"></i>
                Global Modifiers
            </h2>
            <div id="global-controls" class="space-y-4"></div>
        </div>
    </aside>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_fft_values[5];
        uniform float u_global_twist;
        uniform float u_time_speed;
        uniform float u_num_arms_base;
        uniform float u_num_arms_mod;

        vec2 get_fft_factor(int index) {
            if (index == 0) return vec2(10.0, 5.0);
            if (index == 1) return vec2(20.0, 1.5);
            if (index == 2) return vec2(30.0, -0.5);
            if (index == 3) return vec2(40.0, 1.5);
            return vec2(50.0, 2.0);
        }

        vec3 palette_fire(float t, float factor) {
            vec3 a = vec3(0.5, 0.1, 0.0);
            vec3 b = vec3(0.6, 0.3, 0.1);
            vec3 c = vec3(1.0, 1.0, 0.0);
            vec3 d = vec3(0.8, 0.7, 0.2);

            a += 0.1 * sin(vec3(0.1, 0.2, 0.3) * factor);
            b += 0.2 * cos(vec3(0.2, 0.3, 0.1) * factor);

            return a + b * cos(6.28318 * (c * t + d));
        }

        vec3 calculateLayerColor(vec2 st, float i, float fft_value, float adjusted_time) {
            int index = int(i - 1.0);
            vec2 data = get_fft_factor(index);
            float factor = data.y;

            vec2 st0 = st;
            float sgn = 1.0 - 2.0 * mod(i, 2.0);

            float t = adjusted_time * 0.02 - i;
            st0 *= mat2(cos(t), sin(t), -sin(t), cos(t));

            float R = length(st0);
            float d = R * i;
            float angle = atan(st0.y, st0.x);
            float num_arms = u_num_arms_base + u_num_arms_mod * sin(adjusted_time * 0.1 + i);
            float angle_warped = angle * num_arms;

            float dist_warp_factor = fft_value * factor + 0.3 * sin(angle * 12.0 + adjusted_time * factor - i);
            float d_warped = d * dist_warp_factor;

            vec3 pal = palette_fire(-exp((length(d_warped) * -0.9)),
                            abs(d_warped) * 2.0 + adjusted_time * 4.0 + 17.5 * i);

            float radial = exp(-R);
            radial *= smoothstep(1.2, 0.5, R);
            pal *= radial;
            float phase = -(d_warped + sgn * angle_warped) + adjusted_time * 0.3;

            float v = sin(phase);
            v = max(abs(v), 0.01);
            float w = pow(0.02 / v, 0.8);
            
            return pal * w;
        }

        void main() {
            vec2 st = (gl_FragCoord.xy / u_resolution.xy) * 2.0 - 1.0;
            st.x *= u_resolution.x / u_resolution.y;
            
            float adjusted_time = u_time * u_time_speed;

            float R_global = length(st);
            float twist = u_global_twist * sin(R_global * 3.0 - adjusted_time * 0.4);
            st *= mat2(cos(twist), sin(twist), -sin(twist), cos(twist));

            vec3 color = vec3(0.0);
            
            color += calculateLayerColor(st, 1.0, u_fft_values[0], adjusted_time);
            color += calculateLayerColor(st, 2.0, u_fft_values[1], adjusted_time);
            color += calculateLayerColor(st, 3.0, u_fft_values[2], adjusted_time);
            color += calculateLayerColor(st, 4.0, u_fft_values[3], adjusted_time);
            color += calculateLayerColor(st, 5.0, u_fft_values[4], adjusted_time);

            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        const controlsConfig = {
            fft: [
                { id: 'fft_1', label: 'Frequency 1', min: 0.0, max: 2.0, step: 0.01, value: 0.8, uniform: 'u_fft_values', index: 0 },
                { id: 'fft_2', label: 'Frequency 2', min: 0.0, max: 2.0, step: 0.01, value: 0.6, uniform: 'u_fft_values', index: 1 },
                { id: 'fft_3', label: 'Frequency 3', min: 0.0, max: 2.0, step: 0.01, value: 1.2, uniform: 'u_fft_values', index: 2 },
                { id: 'fft_4', label: 'Frequency 4', min: 0.0, max: 2.0, step: 0.01, value: 0.7, uniform: 'u_fft_values', index: 3 },
                { id: 'fft_5', label: 'Frequency 5', min: 0.0, max: 2.0, step: 0.01, value: 0.9, uniform: 'u_fft_values', index: 4 },
            ],
            global: [
                { id: 'global_twist', label: 'Global Twist', min: 0.0, max: 2.0, step: 0.01, value: 0.5, uniform: 'u_global_twist' },
                { id: 'time_speed', label: 'Time Speed', min: 0.0, max: 2.0, step: 0.01, value: 1.0, uniform: 'u_time_speed' },
                { id: 'num_arms_base', label: 'Arm Count', min: 1.0, max: 10.0, step: 0.1, value: 4.0, uniform: 'u_num_arms_base' },
                { id: 'num_arms_mod', label: 'Arm Modulation', min: 0.0, max: 10.0, step: 0.1, value: 3.0, uniform: 'u_num_arms_mod' },
            ]
        };
        
        let controlValues = {};

        function createSlider(config) {
            const container = document.createElement('div');
            container.className = 'flex flex-col space-y-2';

            const header = document.createElement('div');
            header.className = 'flex justify-between items-center text-xs';

            const label = document.createElement('label');
            label.htmlFor = config.id;
            label.textContent = config.label;
            label.className = 'text-gray-400 font-medium';
            
            const valueDisplay = document.createElement('span');
            valueDisplay.id = `${config.id}-value`;
            valueDisplay.textContent = parseFloat(config.value).toFixed(2);
            valueDisplay.className = 'px-2 py-0.5 bg-gray-700 rounded-md font-mono';
            
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.id = config.id;
            slider.min = config.min;
            slider.max = config.max;
            slider.step = config.step;
            slider.value = config.value;
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                valueDisplay.textContent = value.toFixed(2);
                if (config.uniform === 'u_fft_values') {
                    controlValues.fft[config.index] = value;
                } else {
                    controlValues.global[config.id] = value;
                }
            });

            container.appendChild(header);
            container.appendChild(slider);

            return container;
        }

        function initializeControls() {
            const fftContainer = document.getElementById('fft-controls');
            const globalContainer = document.getElementById('global-controls');

            controlValues.fft = controlsConfig.fft.map(c => c.value);
            controlValues.global = {};

            controlsConfig.fft.forEach(cfg => {
                fftContainer.appendChild(createSlider(cfg));
            });

            controlsConfig.global.forEach(cfg => {
                controlValues.global[cfg.id] = cfg.value;
                globalContainer.appendChild(createSlider(cfg));
            });
            
            document.getElementById('reset-button').addEventListener('click', resetControls);
        }
        
        function resetControls() {
            const allConfigs = [...controlsConfig.fft, ...controlsConfig.global];
            allConfigs.forEach(cfg => {
                const slider = document.getElementById(cfg.id);
                const valueDisplay = document.getElementById(`${cfg.id}-value`);
                slider.value = cfg.value;
                valueDisplay.textContent = parseFloat(cfg.value).toFixed(2);
                if (cfg.uniform === 'u_fft_values') {
                    controlValues.fft[cfg.index] = cfg.value;
                } else {
                    controlValues.global[cfg.id] = cfg.value;
                }
            });
        }
        
        function main() {
            initializeControls();
            
            const canvas = document.getElementById('gl-canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WebGL not supported');
                return;
            }

            const vsSource = document.getElementById('vertex-shader').textContent;
            const fsSource = document.getElementById('fragment-shader').textContent;

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            gl.useProgram(shaderProgram);

            const uniforms = {
                resolution: gl.getUniformLocation(shaderProgram, 'u_resolution'),
                time: gl.getUniformLocation(shaderProgram, 'u_time'),
                fft_values: gl.getUniformLocation(shaderProgram, 'u_fft_values'),
                global_twist: gl.getUniformLocation(shaderProgram, 'u_global_twist'),
                time_speed: gl.getUniformLocation(shaderProgram, 'u_time_speed'),
                num_arms_base: gl.getUniformLocation(shaderProgram, 'u_num_arms_base'),
                num_arms_mod: gl.getUniformLocation(shaderProgram, 'u_num_arms_mod'),
            };

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, 1, 1, 1, -1, -1, 1, -1];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const positionAttributeLocation = gl.getAttribLocation(shaderProgram, "a_position");
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            let startTime = performance.now();
            let lastFrameTime = startTime;
            let frameCount = 0;

            function render(currentTime) {
                currentTime *= 0.001;
                const elapsedTime = (performance.now() - startTime) / 1000.0;
                
                frameCount++;
                const delta = currentTime - lastFrameTime;
                if(delta >= 1.0) {
                    const fps = frameCount / delta;
                    document.getElementById('fps-display').textContent = `FPS: ${fps.toFixed(1)}`;
                    frameCount = 0;
                    lastFrameTime = currentTime;
                }

                const dpr = window.devicePixelRatio || 1;
                const displayWidth = Math.floor(canvas.clientWidth * dpr);
                const displayHeight = Math.floor(canvas.clientHeight * dpr);
                if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                    canvas.width = displayWidth;
                    canvas.height = displayHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }

                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.useProgram(shaderProgram);
                gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
                gl.uniform1f(uniforms.time, elapsedTime);
                gl.uniform1fv(uniforms.fft_values, controlValues.fft);
                gl.uniform1f(uniforms.global_twist, controlValues.global.global_twist);
                gl.uniform1f(uniforms.time_speed, controlValues.global.time_speed);
                gl.uniform1f(uniforms.num_arms_base, controlValues.global.num_arms_base);
                gl.uniform1f(uniforms.num_arms_mod, controlValues.global.num_arms_mod);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        document.getElementById('fullscreen-button').addEventListener('click', () => {
            const doc = document.documentElement;
            if (!document.fullscreenElement) {
                doc.requestFullscreen().catch(err => {
                    alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        });

        window.onload = main;
    </script>
</body>
</html>