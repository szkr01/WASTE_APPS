<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MOSAIC.FLAC</title>
    <meta name="description" content="Create stunning mosaic art by selecting parts of your image. Adjust the pixelation level for the perfect effect using AI-powered segmentation.">
    <meta name="page:icon" content="fas fa-palette">
    <meta name="page:color" content="#38bdf8">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            overflow: hidden;
        }

        .main-panel {
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(230, 230, 230, 0.8);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
        }

        .gradient-text {
            background: linear-gradient(90deg, #38bdf8, #818cf8, #c084fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }

        #container {
            position: relative;
            cursor: crosshair;
            background-color: #f9fafb;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.05), inset 0 0 15px rgba(0, 0, 0, 0.05);
        }

        #image-canvas,
        #mosaic-canvas,
        #mask-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #mask-canvas {
            opacity: 0.6;
            pointer-events: none;
        }

        #mosaic-canvas {
            pointer-events: none;
        }

        .icon {
            position: absolute;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            pointer-events: none;
            filter: drop-shadow(0px 0px 3px rgba(0, 0, 0, 0.9));
        }

        #upload-button {
            display: flex;
            transition: all 0.2s ease-in-out;
        }

        #upload-button:hover {
            border-color: #38bdf8;
            background-color: rgba(56, 189, 248, 0.05);
        }

        .control-btn {
            background: linear-gradient(90deg, #38bdf8, #818cf8);
            color: white;
            background-size: 200% 100%;
            transition: background-position 0.4s ease, transform 0.1s ease, box-shadow 0.2s ease;
        }

        .control-btn:hover:not(:disabled) {
            background-position: 100% 0;
            box-shadow: 0 0 15px rgba(129, 140, 248, 0.5);
            transform: translateY(-2px);
        }

        .control-btn:active:not(:disabled) {
            transform: translateY(0px);
        }

        .control-btn:disabled {
            background: #e5e7eb;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            color: #9ca3af;
        }

        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 8px;
            background: #e5e7eb;
            border-radius: 5px; outline: none; opacity: 0.8;
            transition: opacity .2s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 20px; height: 20px;
            background: #818cf8; cursor: pointer;
            border-radius: 50%; border: 2px solid #ffffff;
            box-shadow: 0 0 5px rgba(129, 140, 248, 0.7);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px;
            background: #818cf8; cursor: pointer;
            border-radius: 50%; border: 2px solid #ffffff;
            box-shadow: 0 0 5px rgba(129, 140, 248, 0.7);
        }

        .paint-tool.active-tool {
            border-color: #38bdf8;
            background-color: rgba(56, 189, 248, 0.1);
            box-shadow: 0 0 8px rgba(56, 189, 248, 0.4);
        }
    </style>
</head>

<body class="text-gray-800 flex items-center justify-center h-screen w-screen p-4">

    <!-- NEW: Brush preview cursor element -->
    <div id="brush-cursor" class="absolute rounded-full border-2 border-black bg-white bg-opacity-50 pointer-events-none hidden z-50" style="transform: translate(-50%, -50%);"></div>

    <main class="w-full max-w-7xl h-full flex flex-col lg:flex-row items-center justify-center gap-8">

        <div class="w-full lg:w-3/4 h-auto lg:h-[90vh] flex flex-col main-panel rounded-2xl p-4">
            <h1 class="text-3xl font-bold text-center mb-4 gradient-text">MOSAIC.FLAC</h1>
            <div id="container" class="relative w-full flex-grow rounded-lg overflow-hidden border-2 border-dashed border-gray-300">
                <label id="upload-button" for="upload" class="absolute inset-0 flex flex-col items-center justify-center text-gray-500 cursor-pointer p-4 text-center">
                    <svg class="w-16 h-16 mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                    <!-- ====================== 変更点 1/2 ====================== -->
                    <span class="text-lg font-semibold">Click, Drag & Drop, or Paste an image</span>
                    <!-- ======================================================== -->
                </label>
                <canvas id="image-canvas" style="display: none;"></canvas>
                <canvas id="mosaic-canvas" style="display: none;"></canvas>
                <canvas id="mask-canvas" style="display: none;"></canvas>
            </div>
        </div>

        <div class="w-full lg:w-1/4 h-auto lg:h-[90vh] flex flex-col gap-6 main-panel rounded-2xl p-6 overflow-y-auto">
            
            <div class="flex flex-col gap-4">
                <h2 class="text-2xl font-bold border-b border-gray-300 pb-2">Actions</h2>
                <div class="space-y-3">
                    <button id="toggle-mask" disabled class="w-full flex items-center justify-center gap-2 py-2.5 px-4 rounded-lg font-semibold text-gray-700 bg-white border border-gray-300 shadow-sm transition-all duration-200 ease-in-out hover:bg-gray-50 hover:shadow-md hover:-translate-y-0.5 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                        <i id="toggle-mask-icon" class="fas fa-eye fa-fw"></i>
                        <span id="toggle-mask-text">Hide Mask</span>
                    </button>
                    <button id="reset-image" class="w-full flex items-center justify-center gap-2 py-2.5 px-4 rounded-lg font-semibold text-gray-700 bg-white border border-gray-300 shadow-sm transition-all duration-200 ease-in-out hover:bg-gray-50 hover:shadow-md hover:-translate-y-0.5 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                        <i class="fas fa-trash-arrow-up fa-fw"></i>
                        <span>Reset Image</span>
                    </button>
                    <button id="clear-points" class="w-full flex items-center justify-center gap-2 py-2.5 px-4 rounded-lg font-semibold text-gray-700 bg-white border border-gray-300 shadow-sm transition-all duration-200 ease-in-out hover:bg-gray-50 hover:shadow-md hover:-translate-y-0.5 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                        <i class="fas fa-eraser fa-fw"></i>
                        <span>Clear Selection</span>
                    </button>
                </div>
            </div>

            <div class="flex flex-col gap-4">
                <h2 class="text-2xl font-bold border-b border-gray-300 pb-2">Mosaic Controls</h2>
                <div class="space-y-4">
                    <div class="space-y-2">
                        <label for="block-size-slider" class="flex justify-between items-center font-medium text-gray-600">
                            <span>Block Size</span>
                            <span id="block-size-value" class="font-bold text-sky-600 bg-sky-100/70 px-2 py-1 rounded-md text-sm">20</span>
                        </label>
                        <input id="block-size-slider" type="range" min="5" max="100" value="20" step="1" class="w-full cursor-pointer">
                    </div>
                    <div class="space-y-2">
                        <label for="resolution-slider" class="flex justify-between items-center font-medium text-gray-600">
                            <span>Mask Resolution</span>
                            <span id="resolution-value" class="font-bold text-sky-600 bg-sky-100/70 px-2 py-1 rounded-md text-sm">768</span>
                        </label>
                        <input id="resolution-slider" type="range" min="256" max="1024" value="768" step="128" class="w-full cursor-pointer">
                    </div>
                    <button id="apply-mosaic" disabled class="w-full py-3 px-4 rounded-lg font-semibold shadow-lg control-btn">
                        <i class="fas fa-th mr-2"></i> Apply Mosaic
                    </button>
                    <button id="download-image" disabled class="w-full flex items-center justify-center gap-2 py-2.5 px-4 rounded-lg font-semibold text-gray-700 bg-white border border-gray-300 shadow-sm transition-all duration-200 ease-in-out hover:bg-gray-50 hover:shadow-md hover:-translate-y-0.5 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                        <i class="fas fa-download fa-fw"></i>
                        <span>Download Image</span>
                    </button>
                </div>
            </div>
            
            <div class="flex flex-col gap-4">
                <h2 class="text-2xl font-bold border-b border-gray-300 pb-2">Paint Tools</h2>
                <div class="space-y-3">
                    <div class="grid grid-cols-3 gap-2">
                        <button data-tool="select" class="paint-tool flex flex-col items-center justify-center p-2 rounded-lg border border-gray-300 bg-white transition-all">
                            <i class="fas fa-mouse-pointer fa-fw"></i><span class="text-xs mt-1 font-semibold">Select</span>
                        </button>
                        <button data-tool="brush" class="paint-tool flex flex-col items-center justify-center p-2 rounded-lg border border-gray-300 bg-white transition-all">
                            <i class="fas fa-paint-brush fa-fw"></i><span class="text-xs mt-1 font-semibold">Brush</span>
                        </button>
                        <button data-tool="eraser" class="paint-tool flex flex-col items-center justify-center p-2 rounded-lg border border-gray-300 bg-white transition-all">
                            <i class="fas fa-eraser fa-fw"></i><span class="text-xs mt-1 font-semibold">Eraser</span>
                        </button>
                    </div>
                    <div class="space-y-2 pt-2">
                        <label for="brush-size-slider" class="flex justify-between items-center font-medium text-gray-600">
                            <span>Brush Size</span>
                            <span id="brush-size-value" class="font-bold text-sky-600 bg-sky-100/70 px-2 py-1 rounded-md text-sm">20</span>
                        </label>
                        <input id="brush-size-slider" type="range" min="1" max="100" value="20" step="1" class="w-full cursor-pointer">
                    </div>
                </div>
            </div>

            <div class="flex flex-col gap-4">
                <h2 class="text-2xl font-bold border-b border-gray-300 pb-2">How to Use</h2>
                <div class="text-sm text-gray-600 space-y-2 text-center">
                    <p>1. Upload an image.</p>
                    <p>2. Use tools to create a mask.</p>
                    <p>3. <span class="font-bold text-green-500">Left-click</span> to add to mask.</p>
                    <p>4. <span class="font-bold text-red-500">Right-click</span> to remove from mask.</p>
                </div>
                <div class="bg-sky-100/70 p-4 rounded-lg border border-sky-200 mt-2">
                    <p id="status" class="text-center font-semibold text-lg min-h-[28px] text-sky-600 break-words"></p>
                </div>
            </div>
        </div>
    </main>

    <input id="upload" type="file" accept="image/*" class="hidden" />

    <script type="module">
        // Worker code remains unchanged
        const workerCode = `
            import { env, SamModel, AutoProcessor, RawImage, Tensor } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.14.0';

            env.allowLocalModels = false;

            class SegmentAnythingSingleton {
                static model_id = 'Xenova/slimsam-77-uniform';
                static model;
                static processor;
                static quantized = true;

                static getInstance() {
                    if (!this.model) {
                        this.model = SamModel.from_pretrained(this.model_id, {
                            quantized: this.quantized,
                        });
                    }
                    if (!this.processor) {
                        this.processor = AutoProcessor.from_pretrained(this.model_id);
                    }

                    return Promise.all([this.model, this.processor]);
                }
            }


            let image_embeddings = null;
            let image_inputs = null;
            let ready = false;

            self.onmessage = async (e) => {
                const [model, processor] = await SegmentAnythingSingleton.getInstance();
                if (!ready) {
                    ready = true;
                    self.postMessage({
                        type: 'ready',
                    });
                }

                const { type, data } = e.data;
                if (type === 'reset') {
                    image_inputs = null;
                    image_embeddings = null;

                } else if (type === 'segment') {
                    self.postMessage({
                        type: 'segment_result',
                        data: 'start',
                    });
                    
                    const { image: imageData, resolution } = data;
                    const image = await RawImage.read(imageData);
                    
                    if (processor.image_processor && resolution) {
                        processor.image_processor.config.size = { longest_edge: resolution };
                    }
                    
                    image_inputs = await processor(image);
                    image_embeddings = await model.get_image_embeddings(image_inputs)

                    self.postMessage({
                        type: 'segment_result',
                        data: 'done',
                    });

                } else if (type === 'decode') {
                    if (!image_inputs) return;
                    const reshaped = image_inputs.reshaped_input_sizes[0];
                    const points = data.map(x => [x.point[0] * reshaped[1], x.point[1] * reshaped[0]])
                    const labels = data.map(x => BigInt(x.label));

                    const input_points = new Tensor(
                        'float32',
                        points.flat(Infinity),
                        [1, 1, points.length, 2],
                    )
                    const input_labels = new Tensor(
                        'int64',
                        labels.flat(Infinity),
                        [1, 1, labels.length],
                    )

                    const outputs = await model({
                        ...image_embeddings,
                        input_points,
                        input_labels,
                    })

                    const masks = await processor.post_process_masks(
                        outputs.pred_masks,
                        image_inputs.original_sizes,
                        image_inputs.reshaped_input_sizes,
                    );

                    self.postMessage({
                        type: 'decode_result',
                        data: {
                            mask: RawImage.fromTensor(masks[0][0]),
                            scores: outputs.iou_scores.data,
                        },
                    });

                } else {
                    throw new Error(\`Unknown message type: \${type}\`);
                }
            }
        `;

        const statusLabel = document.getElementById('status');
        const fileUpload = document.getElementById('upload');
        const imageContainer = document.getElementById('container');
        const imageCanvas = document.getElementById('image-canvas');
        const mosaicCanvas = document.getElementById('mosaic-canvas');
        const maskCanvas = document.getElementById('mask-canvas'); 
        const uploadButton = document.getElementById('upload-button');
        const resetButton = document.getElementById('reset-image');
        const clearButton = document.getElementById('clear-points');
        const applyMosaicButton = document.getElementById('apply-mosaic');
        const downloadButton = document.getElementById('download-image');
        const blockSizeSlider = document.getElementById('block-size-slider');
        const blockSizeValue = document.getElementById('block-size-value');
        const toggleMaskButton = document.getElementById('toggle-mask');
        const toggleMaskIcon = document.getElementById('toggle-mask-icon');
        const toggleMaskText = document.getElementById('toggle-mask-text');
        const resolutionSlider = document.getElementById('resolution-slider');
        const resolutionValue = document.getElementById('resolution-value');

        const paintToolButtons = document.querySelectorAll('.paint-tool');
        const brushSizeSlider = document.getElementById('brush-size-slider');
        const brushSizeValue = document.getElementById('brush-size-value');
        const brushCursor = document.getElementById('brush-cursor'); // NEW: Brush cursor element

        let lastPoints = [];
        let isEncoded = false;
        let isDecoding = false;
        let modelReady = false;
        let isMaskVisible = true;

        let currentTool = 'select';
        let isPainting = false;
        let brushSize = 20;
        let lastPos = { x: 0, y: 0 };

        // NEW: Cache for image display dimensions to avoid recalculation
        let imageDisplayInfo = { valid: false };

        const BASE_URL = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/';
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerURL = URL.createObjectURL(blob);
        const worker = new Worker(workerURL, { type: 'module' });

        const star = new Image(); star.src = BASE_URL + 'star-icon.png'; star.className = 'icon';
        const cross = new Image(); cross.src = BASE_URL + 'cross-icon.png'; cross.className = 'icon';

        worker.addEventListener('message', (e) => {
            const { type, data } = e.data;
            if (type === 'ready') {
                modelReady = true; statusLabel.textContent = 'Model Ready';
            } else if (type === 'decode_result') {
                isDecoding = false; if (!isEncoded) return;
                const { mask, scores } = data;
                const tempCanvas = new OffscreenCanvas(mask.width, mask.height);
                const tempCtx = tempCanvas.getContext('2d');
                const imageData = tempCtx.createImageData(mask.width, mask.height);

                let bestIndex = 0; scores.forEach((s, i) => { if (s > scores[bestIndex]) bestIndex = i; });
                statusLabel.textContent = `Segment Score: ${scores[bestIndex].toFixed(2)}`;

                for (let i = 0; i < imageData.data.length / 4; ++i) {
                    if (mask.data[scores.length * i + bestIndex] === 1) {
                        imageData.data[4 * i + 0] = 56; imageData.data[4 * i + 1] = 189;
                        imageData.data[4 * i + 2] = 248; imageData.data[4 * i + 3] = 255;
                    }
                }
                tempCtx.putImageData(imageData, 0, 0);
                
                const mainMaskCtx = maskCanvas.getContext('2d');
                const lastClickLabel = lastPoints.length > 0 ? lastPoints[lastPoints.length - 1].label : 1;
                mainMaskCtx.globalCompositeOperation = (lastClickLabel === 0) ? 'destination-out' : 'source-over';
                mainMaskCtx.drawImage(tempCanvas, 0, 0);
                mainMaskCtx.globalCompositeOperation = 'source-over';
            } else if (type === 'segment_result') {
                statusLabel.textContent = data === 'start' ? 'Extracting image embedding...' : 'Embedding extracted!';
                if (data === 'done') isEncoded = true;
            }
        });

        // --- NEW: Accurate Coordinate Calculation ---
        function calculateImageDisplayInfo() {
            const canvas = imageCanvas;
            const rect = imageContainer.getBoundingClientRect();
            if (rect.width === 0 || canvas.width === 0 || canvas.height === 0) {
                imageDisplayInfo = { valid: false }; return;
            }
            const imageAR = canvas.width / canvas.height;
            const containerAR = rect.width / rect.height;
            let displayW, displayH, offsetX, offsetY;
            if (imageAR > containerAR) {
                displayW = rect.width; displayH = displayW / imageAR;
                offsetX = 0; offsetY = (rect.height - displayH) / 2;
            } else {
                displayH = rect.height; displayW = displayH * imageAR;
                offsetY = 0; offsetX = (rect.width - displayW) / 2;
            }
            imageDisplayInfo = {
                valid: true, rect, displayW, displayH, offsetX, offsetY,
                scale: canvas.width / displayW
            };
        }

        function getCanvasCoordinates(evt) {
            if (!imageDisplayInfo.valid) return null;
            const { rect, displayW, displayH, offsetX, offsetY, scale } = imageDisplayInfo;
            const mouseX = evt.clientX - rect.left;
            const mouseY = evt.clientY - rect.top;
            if (mouseX < offsetX || mouseX > offsetX + displayW || mouseY < offsetY || mouseY > offsetY + displayH) return null;
            const ratioX = (mouseX - offsetX) / displayW;
            const ratioY = (mouseY - offsetY) / displayH;
            return {
                ratioX, ratioY,
                x: ratioX * imageCanvas.width,
                y: ratioY * imageCanvas.height,
                scale
            };
        }
        window.addEventListener('resize', calculateImageDisplayInfo);


        function decode() {
            if (isDecoding || lastPoints.length === 0) return;
            isDecoding = true;
            worker.postMessage({ type: 'decode', data: lastPoints });
        }

        function clearPointsAndMask() {
            lastPoints = [];
            document.querySelectorAll('.icon').forEach(e => e.remove());
            [applyMosaicButton, downloadButton, toggleMaskButton].forEach(b => b.disabled = true);
            maskCanvas.getContext('2d').clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            mosaicCanvas.getContext('2d').clearRect(0, 0, mosaicCanvas.width, mosaicCanvas.height);
            if (!isMaskVisible) {
                isMaskVisible = true; maskCanvas.style.display = 'block';
                toggleMaskIcon.className = 'fas fa-eye fa-fw'; toggleMaskText.textContent = 'Hide Mask';
            }
        }
        clearButton.addEventListener('click', clearPointsAndMask);

        resetButton.addEventListener('click', () => {
            isEncoded = false; worker.postMessage({ type: 'reset' });
            imageCanvas.getContext('2d').clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            clearPointsAndMask();
            [imageCanvas, maskCanvas, mosaicCanvas].forEach(c => c.style.display = 'none');
            uploadButton.style.display = 'flex';
            statusLabel.textContent = 'Model Ready';
            imageDisplayInfo.valid = false;
        });

        function segment(imageData) {
            clearPointsAndMask(); isEncoded = false;
            if (!modelReady) statusLabel.textContent = 'Loading model...';
            const image = new Image();
            image.onload = () => {
                [imageCanvas, maskCanvas, mosaicCanvas].forEach(c => {
                    c.width = image.naturalWidth; c.height = image.naturalHeight;
                });
                imageCanvas.getContext('2d').drawImage(image, 0, 0);
                uploadButton.style.display = 'none';
                [imageCanvas, maskCanvas, mosaicCanvas].forEach(c => c.style.display = 'block');
                calculateImageDisplayInfo(); // MODIFIED: Calculate dimensions after load
                const resolution = parseInt(resolutionSlider.value, 10);
                worker.postMessage({ type: 'segment', data: { image: imageData, resolution } });
            };
            image.src = imageData;
        }
        fileUpload.addEventListener('change', e => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = e2 => segment(e2.target.result);
            reader.readAsDataURL(file);
        });

        // ====================== 変更点 2/2 ======================
        // Drag & Drop and Paste Image Input
        function handleImageFile(file) {
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => segment(e.target.result);
                reader.readAsDataURL(file);
            } else {
                statusLabel.textContent = 'Please provide an image file.';
            }
        }

        // Drag and Drop
        imageContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (!isEncoded) { // Only show feedback if no image is loaded
                uploadButton.classList.add('bg-sky-50');
                imageContainer.classList.add('border-sky-400');
                imageContainer.classList.remove('border-gray-300');
            }
        });

        imageContainer.addEventListener('dragleave', (e) => {
            e.preventDefault();
             if (!isEncoded) {
                uploadButton.classList.remove('bg-sky-50');
                imageContainer.classList.remove('border-sky-400');
                imageContainer.classList.add('border-gray-300');
            }
        });

        imageContainer.addEventListener('drop', (e) => {
            e.preventDefault();
             if (!isEncoded) {
                uploadButton.classList.remove('bg-sky-50');
                imageContainer.classList.remove('border-sky-400');
                imageContainer.classList.add('border-gray-300');
            }
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                handleImageFile(e.dataTransfer.files[0]);
            }
        });

        // Paste from clipboard
        window.addEventListener('paste', (e) => {
            if (e.clipboardData && e.clipboardData.items) {
                const items = e.clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1) {
                        const file = items[i].getAsFile();
                        handleImageFile(file);
                        break; // Stop after finding the first image
                    }
                }
            }
        });
        // ==========================================================

        function addIcon({ point, label }) {
            if (!imageDisplayInfo.valid) return;
            const icon = (label === 1 ? star : cross).cloneNode();
            const { displayW, displayH, offsetX, offsetY } = imageDisplayInfo;
            const iconX = offsetX + point[0] * displayW;
            const iconY = offsetY + point[1] * displayH;
            icon.style.left = `${iconX}px`;
            icon.style.top = `${iconY}px`;
            icon.style.display = (isMaskVisible && currentTool === 'select') ? 'block' : 'none';
            imageContainer.appendChild(icon);
        }

        function getPoint(e) { // MODIFIED: Uses new coordinate function
            const coords = getCanvasCoordinates(e);
            if (!coords) return null;
            return { point: [coords.ratioX, coords.ratioY], label: e.button === 2 ? 0 : 1 };
        }

        imageContainer.addEventListener('mousedown', e => {
            if (!isEncoded) return;
            e.preventDefault();
            if (currentTool === 'select') {
                if (e.button !== 0 && e.button !== 2) return;
                const point = getPoint(e); if (!point) return;
                [applyMosaicButton, downloadButton, toggleMaskButton].forEach(b => b.disabled = false);
                lastPoints.push(point); addIcon(point); decode();
            } else { startPainting(e); }
        });
        
        imageContainer.addEventListener('contextmenu', e => e.preventDefault());

        // --- MODIFIED: Paint Logic with accurate coordinates ---
        function startPainting(e) {
            const coords = getCanvasCoordinates(e); if (!coords) return;
            isPainting = true;
            [applyMosaicButton, downloadButton, toggleMaskButton].forEach(b => b.disabled = false);
            lastPos = { x: coords.x, y: coords.y };
            draw(e);
        }

        function stopPainting() { if (isPainting) { isPainting = false; maskCanvas.getContext('2d').beginPath(); } }
        
        function draw(e) {
            if (!isPainting) return;
            const coords = getCanvasCoordinates(e);
            if (!coords) { stopPainting(); return; }
            const maskCtx = maskCanvas.getContext('2d');
            maskCtx.beginPath();
            maskCtx.lineWidth = brushSize * coords.scale;
            maskCtx.lineCap = 'round'; maskCtx.lineJoin = 'round';
            maskCtx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
            maskCtx.strokeStyle = (currentTool === 'brush') ? 'rgba(56, 189, 248, 1)' : 'rgba(0,0,0,1)';
            maskCtx.moveTo(lastPos.x, lastPos.y);
            maskCtx.lineTo(coords.x, coords.y);
            maskCtx.stroke();
            lastPos = { x: coords.x, y: coords.y };
        }
        
        imageContainer.addEventListener('mousemove', e => {
            if (currentTool === 'brush' || currentTool === 'eraser') {
                const coords = getCanvasCoordinates(e);
                if (coords) {
                    brushCursor.style.display = 'block';
                    brushCursor.style.left = `${e.clientX}px`;
                    brushCursor.style.top = `${e.clientY}px`;
                } else { brushCursor.style.display = 'none'; }
            }
            draw(e);
        });
        imageContainer.addEventListener('mouseup', stopPainting);
        imageContainer.addEventListener('mouseleave', () => { stopPainting(); brushCursor.style.display = 'none'; });
        imageContainer.addEventListener('mouseenter', () => { if(isEncoded && (currentTool === 'brush' || currentTool === 'eraser')) brushCursor.style.display = 'block' });


        // --- MODIFIED: Tool Selection Logic for mode separation ---
        paintToolButtons.forEach(button => {
            button.addEventListener('click', () => {
                paintToolButtons.forEach(btn => btn.classList.remove('active-tool'));
                button.classList.add('active-tool');
                currentTool = button.dataset.tool;
                const icons = document.querySelectorAll('.icon');
                if (currentTool === 'select') {
                    imageContainer.style.cursor = 'crosshair';
                    brushCursor.style.display = 'none';
                    icons.forEach(icon => icon.style.display = isMaskVisible ? 'block' : 'none');
                } else {
                    imageContainer.style.cursor = 'none';
                    brushCursor.style.display = 'block';
                    icons.forEach(icon => icon.style.display = 'none');
                }
            });
        });
        document.querySelector('[data-tool="select"]').click();

        brushSizeSlider.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value, 10);
            brushSizeValue.textContent = brushSize;
            brushCursor.style.width = `${brushSize}px`; brushCursor.style.height = `${brushSize}px`;
        });
        brushCursor.style.width = `${brushSize}px`; brushCursor.style.height = `${brushSize}px`; // Set initial size

        blockSizeSlider.addEventListener('input', e => { blockSizeValue.textContent = e.target.value; });
        resolutionSlider.addEventListener('input', e => { resolutionValue.textContent = e.target.value; });

        function applyMosaic() {
            statusLabel.textContent = 'Applying mosaic...';
            const gridSize = parseInt(blockSizeSlider.value, 10);
            const imageCtx = imageCanvas.getContext('2d', { willReadFrequently: true });
            const maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
            const mosaicCtx = mosaicCanvas.getContext('2d');
            const [w, h] = [imageCanvas.width, imageCanvas.height]; if (w === 0 || h === 0) return;
            const imageData = imageCtx.getImageData(0, 0, w, h).data;
            const maskData = maskCtx.getImageData(0, 0, w, h).data;
            mosaicCtx.clearRect(0, 0, w, h);
            for (let y = 0; y < h; y += gridSize) for (let x = 0; x < w; x += gridSize) {
                let isMasked = false;
                for (let j = 0; j < gridSize && y + j < h; j++) {
                    for (let i = 0; i < gridSize && x + i < w; i++) {
                        if (maskData[((y + j) * w + (x + i)) * 4 + 3] > 0) { isMasked = true; break; }
                    } if (isMasked) break;
                }
                if (isMasked) {
                    let r = 0, g = 0, b = 0, count = 0;
                    for (let j = 0; j < gridSize && y + j < h; j++) for (let i = 0; i < gridSize && x + i < w; i++) {
                        const idx = ((y + j) * w + (x + i)) * 4;
                        r += imageData[idx]; g += imageData[idx + 1]; b += imageData[idx + 2]; count++;
                    }
                    mosaicCtx.fillStyle = `rgb(${r/count}, ${g/count}, ${b/count})`;
                    mosaicCtx.fillRect(x, y, gridSize, gridSize);
                }
            }
            statusLabel.textContent = 'Mosaic applied!';
        }
        applyMosaicButton.addEventListener('click', applyMosaic);

        async function downloadImage() {
            const [w, h] = [imageCanvas.width, imageCanvas.height]; if (w === 0 || h === 0) return;
            statusLabel.textContent = 'Preparing download...';
            const downloadCanvas = new OffscreenCanvas(w, h);
            const ctx = downloadCanvas.getContext('2d');
            ctx.drawImage(imageCanvas, 0, 0); ctx.drawImage(mosaicCanvas, 0, 0);
            const link = document.createElement('a');
            link.download = 'mosaic-art.png'; link.href = URL.createObjectURL(await downloadCanvas.convertToBlob());
            link.click(); link.remove(); statusLabel.textContent = 'Image downloaded!';
        }
        downloadButton.addEventListener('click', downloadImage);
        
        toggleMaskButton.addEventListener('click', () => {
            isMaskVisible = !isMaskVisible;
            const displayStyle = isMaskVisible ? 'block' : 'none';
            maskCanvas.style.display = displayStyle;
            if (currentTool === 'select') { // MODIFIED: Only toggle icons if in select mode
                document.querySelectorAll('.icon').forEach(icon => icon.style.display = displayStyle);
            }
            toggleMaskIcon.className = `fas fa-eye${isMaskVisible ? '' : '-slash'} fa-fw`;
            toggleMaskText.textContent = `${isMaskVisible ? 'Hide' : 'Show'} Mask`;
        });

    </script>
</body>
</html>