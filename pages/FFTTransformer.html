<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Informative Drawings: Web Vectorizer</title>
	<meta name="description"
		content="An interactive web application to extract line art from illustrations using ONNX models, convert each contiguous path into a closed loop, and visualize their Fourier transforms as epicycles.">
	<meta name="page:icon" content="fas fa-palette">
	<meta name="page:color" content="#38bdf8">

	<script src="https://cdn.tailwindcss.com"></script>
	<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
		integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
		crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

	<style>
		body {
			font-family: 'Inter', sans-serif;
			-webkit-font-smoothing: antialiased;
			-moz-osx-font-smoothing: grayscale;
		}

		#loader-overlay {
			background-color: rgba(248, 250, 252, 0.85);
			backdrop-filter: blur(4px);
			transition: opacity 0.3s ease-in-out;
		}

		#loader-overlay.hidden {
			opacity: 0;
			pointer-events: none;
		}

		.spinner {
			border: 4px solid rgba(0, 0, 0, 0.1);
			width: 48px;
			height: 48px;
			border-radius: 50%;
			border-left-color: #38bdf8;
			animation: spin 1s ease-in-out infinite;
		}

		@keyframes spin {
			0% {
				transform: rotate(0deg);
			}

			100% {
				transform: rotate(360deg);
			}
		}

		input[type=range] {
			-webkit-appearance: none;
			background: transparent;
			cursor: pointer;
			width: 100%;
		}

		input[type=range]:focus {
			outline: none;
		}

		input[type=range]::-webkit-slider-runnable-track {
			height: 4px;
			background: #e2e8f0;
			border-radius: 9999px;
		}

		input[type=range]::-webkit-slider-thumb {
			-webkit-appearance: none;
			margin-top: -6px;
			background-color: #38bdf8;
			height: 16px;
			width: 16px;
			border-radius: 50%;
			border: none;
			transition: transform 0.2s ease;
		}

		input[type=range]:hover::-webkit-slider-thumb {
			transform: scale(1.1);
		}

		input[type=range]:focus::-webkit-slider-thumb {
			box-shadow: 0 0 0 3px white, 0 0 0 5px #38bdf8;
		}

		input[type=range]::-moz-range-track {
			height: 4px;
			background: #e2e8f0;
			border-radius: 9999px;
		}

		input[type=range]::-moz-range-thumb {
			background-color: #38bdf8;
			height: 16px;
			width: 16px;
			border-radius: 50%;
			border: none;
			transition: transform 0.2s ease;
		}

		input[type=range]:hover::-moz-range-thumb {
			transform: scale(1.1);
		}

		#visualizations canvas {
			max-width: 100%;
			max-height: 100%;
			height: auto;
			width: auto;
			background-color: white;
			border-radius: 0.25rem;
		}
	</style>
</head>

<body class="bg-slate-50 text-slate-700">

	<div id="loader-overlay" class="fixed inset-0 z-50 flex-col items-center justify-center hidden">
		<div class="spinner"></div>
		<p id="loader-status" class="mt-4 text-sm font-medium text-slate-600 tracking-wide"></p>
	</div>

	<div class="flex flex-col md:flex-row min-h-screen">
		<aside id="sidebar"
			class="w-full md:w-80 lg:w-96 bg-white border-r border-slate-200 p-6 lg:p-8 flex flex-col flex-shrink-0">
			<div class="flex-grow">
				<header class="mb-10">
					<h1 class="text-2xl font-bold text-slate-800 flex items-center gap-3">
						<i class="fas fa-palette text-sky-500"></i>
						<span>Informative Drawings</span>
					</h1>
					<p class="text-sm text-slate-500 mt-1">AI-Powered Vector Art Visualizer</p>
				</header>

				<div class="space-y-8">
					<div>
						<h2 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-3">1. Input</h2>
						<label for="image-upload"
							class="group cursor-pointer flex flex-col items-center justify-center w-full h-32 bg-slate-50 border-2 border-slate-200 border-dashed rounded-lg transition-colors hover:bg-sky-50 hover:border-sky-300">
							<div class="flex flex-col items-center justify-center pt-5 pb-6 text-center px-2">
								<i
									class="fas fa-upload text-2xl text-slate-400 group-hover:text-sky-500 transition-colors"></i>
								<p id="upload-prompt"
									class="mt-2 text-sm text-slate-500 group-hover:text-sky-600 truncate max-w-full">
									<span class="font-semibold">Click to upload</span> or drag and drop</p>
								<p class="text-xs text-slate-400">PNG, JPG, WEBP, etc.</p>
							</div>
							<input id="image-upload" type="file" class="hidden" accept="image/*" />
						</label>
					</div>

					<div>
						<h2 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-3">2. Configuration
						</h2>
						<div class="space-y-4">
							<div>
								<label for="model-select" class="block text-sm font-medium text-slate-700 mb-1.5">AI
									Model</label>
								<select id="model-select"
									class="block w-full p-2.5 bg-slate-50 border border-slate-300 text-slate-900 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 transition">
									<option value="opensketch_style_512x512.onnx">OpenSketch</option>
									<option value="anime_style_512x512.onnx">Anime</option>
									<option value="contour_style_512x512.onnx">Contour</option>
								</select>
							</div>
							<div>
								<label for="gap-tolerance"
									class="flex justify-between text-sm font-medium text-slate-700 mb-1.5">
									<span>Gap Tolerance</span>
									<span id="gap-tolerance-label" class="font-semibold text-sky-600">0px</span>
								</label>
								<input id="gap-tolerance" type="range" min="0" max="5" value="0">
							</div>
						</div>
					</div>

					<div>
						<h2 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-3">3. Visualization
						</h2>
						<div>
							<label for="fft-vectors"
								class="flex justify-between text-sm font-medium text-slate-700 mb-1.5">
								<span>Drawing Detail</span>
								<span id="fft-vectors-label" class="font-semibold text-sky-600">100%</span>
							</label>
							<input id="fft-vectors" type="range" min="1" max="100" value="100">
						</div>
					</div>
				</div>
			</div>

			<div class="mt-8">
				<button id="process-button"
					class="w-full bg-sky-500 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 shadow-md transform hover:scale-105 hover:bg-sky-600 disabled:bg-slate-300 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
					<i class="fas fa-cogs mr-2"></i>Process Image
				</button>
				<p id="status-message" class="mt-4 text-center text-slate-500 text-xs tracking-wide h-4"></p>
			</div>
		</aside>

		<main class="flex-1 p-6 lg:p-10 bg-slate-100/50">
			<div class="max-w-7xl mx-auto">
				<header class="mb-8">
					<h1 class="text-3xl md:text-4xl font-bold text-slate-900">Visualizations</h1>
					<p class="text-slate-500 mt-2 max-w-2xl">From the original image to its Fourier series
						representation. Each step in the process is shown below.</p>
				</header>

				<section id="visualizations" class="grid grid-cols-1 lg:grid-cols-2 gap-6 lg:gap-8">
					<div class="bg-white p-4 sm:p-5 rounded-xl shadow-sm border border-slate-200">
						<h2 class="text-sm font-semibold text-slate-800 mb-3">Original Image</h2>
						<div
							class="bg-slate-100 rounded-lg aspect-square flex items-center justify-center overflow-hidden">
							<canvas id="canvas-original"></canvas></div>
					</div>
					<div class="bg-white p-4 sm:p-5 rounded-xl shadow-sm border border-slate-200">
						<h2 class="text-sm font-semibold text-slate-800 mb-3">Extracted Line Art (ONNX)</h2>
						<div
							class="bg-slate-100 rounded-lg aspect-square flex items-center justify-center overflow-hidden">
							<canvas id="canvas-lineart"></canvas></div>
					</div>
					<div class="bg-white p-4 sm:p-5 rounded-xl shadow-sm border border-slate-200">
						<h2 class="text-sm font-semibold text-slate-800 mb-3">Detected & Closed Paths</h2>
						<div
							class="bg-slate-100 rounded-lg aspect-square flex items-center justify-center overflow-hidden">
							<canvas id="canvas-closed-paths"></canvas></div>
					</div>
					<div class="bg-white p-4 sm:p-5 rounded-xl shadow-sm border border-slate-200">
						<h2 class="text-sm font-semibold text-slate-800 mb-3">FFT Epicycle Visualization</h2>
						<div
							class="bg-slate-100 rounded-lg aspect-square flex items-center justify-center overflow-hidden">
							<canvas id="canvas-fft"></canvas></div>
					</div>
				</section>
			</div>
		</main>
	</div>

	<script>
		const statusEl = document.getElementById('status-message');
		const processButton = document.getElementById('process-button');
		const imageUpload = document.getElementById('image-upload');
		const uploadPrompt = document.getElementById('upload-prompt');
		const modelSelect = document.getElementById('model-select');
		const gapToleranceSlider = document.getElementById('gap-tolerance');
		const gapToleranceLabel = document.getElementById('gap-tolerance-label');
		const fftVectorSlider = document.getElementById('fft-vectors');
		const fftVectorLabel = document.getElementById('fft-vectors-label');

		const loader = {
			overlay: document.getElementById('loader-overlay'),
			status: document.getElementById('loader-status'),
			show(message) {
				this.status.textContent = message;
				this.overlay.classList.remove('hidden');
				this.overlay.classList.add('flex');
			},
			hide() {
				this.overlay.classList.add('hidden');
				this.overlay.classList.remove('flex');
			}
		};

		const canvases = {
			original: document.getElementById('canvas-original'),
			lineart: document.getElementById('canvas-lineart'),
			closedPaths: document.getElementById('canvas-closed-paths'),
			fft: document.getElementById('canvas-fft'),
		};
		const contexts = {
			original: canvases.original.getContext('2d'),
			lineart: canvases.lineart.getContext('2d'),
			closedPaths: canvases.closedPaths.getContext('2d'),
			fft: canvases.fft.getContext('2d'),
		};

		let onnxSession = null;
		let originalImage = null;
		let pathData = [];
		let fftAnimationId = null;

		const MODEL_BASE_URL = "https://raw.githubusercontent.com/Kazuhito00/Informative-Drawings-ONNX-Sample/main/model/";
		const MODEL_INPUT_SIZE = 512;
		const PATH_COLORS = ['#38bdf8','#f43f5e','#10b981','#f97316','#8b5cf6','#ec4899','#65a30d'];

		function updateStatus(message,isError = false) {
			statusEl.textContent = message;
			statusEl.style.color = isError ? '#ef4444' : '#6b7280';
		}

		function clearCanvas(ctx) {
			if(!ctx) return;
			const {width,height} = ctx.canvas;
			ctx.clearRect(0,0,width,height);
			if(ctx === contexts.fft || ctx === contexts.closedPaths) {
				ctx.fillStyle = "white";
				ctx.fillRect(0,0,width,height);
			}
		}

		function clearAllOutputCanvases() {
			clearCanvas(contexts.lineart);
			clearCanvas(contexts.closedPaths);
			clearCanvas(contexts.fft);
			if(fftAnimationId) {
				cancelAnimationFrame(fftAnimationId);
				fftAnimationId = null;
			}
		}

		async function loadOnnxModel() {
			const modelName = modelSelect.value;
			const modelUrl = MODEL_BASE_URL + modelName;
			try {
				onnxSession = await ort.InferenceSession.create(modelUrl,{executionProviders: ['webgl','cpu']});
			} catch(error) {
				console.error(`Failed to load model ${modelName}:`,error);
				onnxSession = null;
				throw error;
			}
		}

		async function initializeApp() {
			updateStatus('Initializing application...');
			loader.show('Loading initial AI model...');
			try {
				await loadOnnxModel();
				updateStatus('Ready. Please upload an image.');
				processButton.disabled = true;
			} catch(error) {
				updateStatus('Error initializing AI. Please reload.',true);
				[modelSelect,imageUpload,processButton,gapToleranceSlider,fftVectorSlider].forEach(el => el.disabled = true);
			} finally {
				loader.hide();
			}
		}

		imageUpload.addEventListener('change',(event) => {
			const file = event.target.files[0];
			if(!file) return;

			uploadPrompt.innerHTML = `<span class="font-semibold">${file.name}</span>`;

			const reader = new FileReader();
			reader.onload = (e) => {
				originalImage = new Image();
				originalImage.onload = () => {
					for(const key in canvases) {
						canvases[key].width = originalImage.width;
						canvases[key].height = originalImage.height;
					}
					contexts.original.drawImage(originalImage,0,0);
					processButton.disabled = false;
					updateStatus('Image loaded. Ready to process.');
					clearAllOutputCanvases();
				};
				originalImage.src = e.target.result;
			};
			reader.readAsDataURL(file);
		});

		modelSelect.addEventListener('change',async () => {
			loader.show(`Loading new model: ${modelSelect.options[modelSelect.selectedIndex].text}...`);
			try {
				await loadOnnxModel();
				updateStatus('New model loaded. Ready to process.');
			} catch(error) {
				updateStatus('Failed to load selected model.',true);
			} finally {
				loader.hide();
			}
		});

		processButton.addEventListener('click',async () => {
			if(!originalImage || !onnxSession) {
				updateStatus('Please upload an image first.',true);
				return;
			}

			processButton.disabled = true;
			clearAllOutputCanvases();
			pathData = [];

			try {
				loader.show('Step 1/4: Running AI model...');
				await runInference();

				loader.show('Step 2/4: Extracting vector paths...');
				const extractedPaths = await extractPathsFromLineArt();

				if(extractedPaths.length === 0) {
					updateStatus('No paths found. Try a different image or model.',true);
					loader.hide();
					processButton.disabled = false;
					return;
				}

				loader.show('Step 3/4: Processing paths & FFT...');
				for(const path of extractedPaths) {
					const closedPath = [...path,...[...path].reverse()];
					const resampledPath = resamplePath(closedPath,Math.min(1024,closedPath.length * 2));
					const fourierCoefficients = dft(resampledPath);
					pathData.push({
						closedPath,
						fourierCoefficients,
						animationState: {time: 0,drawnPath: []}
					});
				}

				drawAllClosedPaths();

				loader.show('Step 4/4: Initializing visualization...');
				startFftAnimation();
				updateStatus(`Complete! Found ${pathData.length} paths.`);

			} catch(error) {
				console.error('Processing failed:',error);
				updateStatus(`An error occurred. Check console.`,true);
			} finally {
				loader.hide();
				processButton.disabled = false;
			}
		});

		async function runInference() {
			const tempCanvas = document.createElement('canvas');
			tempCanvas.width = MODEL_INPUT_SIZE;
			tempCanvas.height = MODEL_INPUT_SIZE;
			const tempCtx = tempCanvas.getContext('2d',{willReadFrequently: true});
			tempCtx.drawImage(originalImage,0,0,MODEL_INPUT_SIZE,MODEL_INPUT_SIZE);

			const imageData = tempCtx.getImageData(0,0,MODEL_INPUT_SIZE,MODEL_INPUT_SIZE);
			const {data} = imageData;
			const float32Data = new Float32Array(3 * MODEL_INPUT_SIZE * MODEL_INPUT_SIZE);

			for(let i = 0;i < MODEL_INPUT_SIZE * MODEL_INPUT_SIZE;i++) {
				float32Data[i] = data[i * 4];
				float32Data[i + MODEL_INPUT_SIZE * MODEL_INPUT_SIZE] = data[i * 4 + 1];
				float32Data[i + 2 * MODEL_INPUT_SIZE * MODEL_INPUT_SIZE] = data[i * 4 + 2];
			}

			const inputName = onnxSession.inputNames[0];
			const inputTensor = new ort.Tensor('float32',float32Data,[1,3,MODEL_INPUT_SIZE,MODEL_INPUT_SIZE]);
			const feeds = {[inputName]: inputTensor};

			const results = await onnxSession.run(feeds);
			const outputName = onnxSession.outputNames[0];
			const outputData = results[outputName].data;

			const outputImageData = contexts.lineart.createImageData(MODEL_INPUT_SIZE,MODEL_INPUT_SIZE);
			for(let i = 0;i < outputData.length;i++) {
				const value = Math.max(0,Math.min(255,outputData[i] * 255));
				outputImageData.data[i * 4] = 255 - value;
				outputImageData.data[i * 4 + 1] = 255 - value;
				outputImageData.data[i * 4 + 2] = 255 - value;
				outputImageData.data[i * 4 + 3] = 255;
			}

			const lineartTempCanvas = document.createElement('canvas');
			lineartTempCanvas.width = MODEL_INPUT_SIZE;
			lineartTempCanvas.height = MODEL_INPUT_SIZE;
			const lineartTempCtx = lineartTempCanvas.getContext('2d');
			lineartTempCtx.putImageData(outputImageData,0,0);

			clearCanvas(contexts.lineart);
			contexts.lineart.fillStyle = "white";
			contexts.lineart.fillRect(0,0,canvases.lineart.width,canvases.lineart.height);
			contexts.lineart.drawImage(lineartTempCanvas,0,0,canvases.lineart.width,canvases.lineart.height);
		}

		function extractPathsFromLineArt() {
			return new Promise(resolve => {
				const ctx = contexts.lineart;
				const {width,height} = ctx.canvas;
				const imageData = ctx.getImageData(0,0,width,height);
				const data = imageData.data;
				const visited = new Uint8Array(width * height);
				const threshold = 128;
				const allPaths = [];
				const minPathLength = 20;
				const gapTolerance = parseInt(gapToleranceSlider.value,10);

				const isBlack = (x,y) => {
					if(x < 0 || x >= width || y < 0 || y >= height) return false;
					const index = (y * width + x);
					return data[index * 4] < threshold && !visited[index];
				};

				const findNextPixel = (x,y) => {
					for(let r = 1;r <= gapTolerance + 1;r++) {
						for(let dy = -r;dy <= r;dy++) {
							for(let dx = -r;dx <= r;dx++) {
								if(dx === 0 && dy === 0) continue;
								const nx = x + dx;
								const ny = y + dy;
								if(isBlack(nx,ny)) return {x: nx,y: ny};
							}
						}
					}
					return null;
				};

				function tracePath(startX,startY) {
					const path = [{x: startX,y: startY}];
					let x = startX,y = startY;
					visited[y * width + x] = 1;

					while(true) {
						const nextPixel = findNextPixel(x,y);
						if(nextPixel) {
							x = nextPixel.x;
							y = nextPixel.y;
							visited[y * width + x] = 1;
							path.push({x,y});
						} else break;
					}
					return path;
				}

				for(let y = 0;y < height;y++) {
					for(let x = 0;x < width;x++) {
						if(isBlack(x,y)) {
							const newPath = tracePath(x,y);
							if(newPath.length > minPathLength) allPaths.push(newPath);
						}
					}
				}
				allPaths.sort((a,b) => b.length - a.length);
				resolve(allPaths);
			});
		}

		function drawAllClosedPaths() {
			const ctx = contexts.closedPaths;
			clearCanvas(ctx);
			ctx.lineWidth = 2;

			pathData.forEach((pData,index) => {
				const path = pData.closedPath;
				if(path.length < 2) return;

				ctx.strokeStyle = PATH_COLORS[index % PATH_COLORS.length];
				ctx.beginPath();
				ctx.moveTo(path[0].x,path[0].y);
				for(let i = 1;i < path.length;i++) {
					ctx.lineTo(path[i].x,path[i].y);
				}
				ctx.stroke();
			});
		}

		function resamplePath(path,numPoints) {
			if(path.length === 0) return [];
			const totalLength = path.reduce((len,p,i) => i > 0 ? len + Math.hypot(p.x - path[i - 1].x,p.y - path[i - 1].y) : 0,0);
			if(totalLength === 0) return Array(numPoints).fill(path[0]);
			const interval = totalLength / (numPoints - 1);
			const newPath = [path[0]];
			let dist = 0;

			for(let i = 1;i < path.length;i++) {
				const p1 = path[i - 1];
				const p2 = path[i];
				if(!p1 || !p2) continue;
				const segmentLength = Math.hypot(p2.x - p1.x,p2.y - p1.y);

				while(dist + segmentLength >= interval * newPath.length) {
					if(newPath.length >= numPoints) return newPath;
					const ratio = (interval * newPath.length - dist) / segmentLength;
					const newX = p1.x + ratio * (p2.x - p1.x);
					const newY = p1.y + ratio * (p2.y - p1.y);
					newPath.push({x: newX,y: newY});
				}
				dist += segmentLength;
			}
			while(newPath.length < numPoints && path.length > 0) newPath.push(path[path.length - 1]);
			return newPath;
		}

		function dft(path) {
			const N = path.length;
			const C = [];
			if(N === 0) return C;

			const scaleX = canvases.fft.width / originalImage.width;
			const scaleY = canvases.fft.height / originalImage.height;
			const centerX = canvases.fft.width / 2;
			const centerY = canvases.fft.height / 2;

			for(let k = 0;k < N;k++) {
				let re = 0,im = 0;
				for(let n = 0;n < N;n++) {
					const phi = (2 * Math.PI * k * n) / N;
					const x = (path[n].x * scaleX) - centerX;
					const y = (path[n].y * scaleY) - centerY;
					re += x * Math.cos(phi) + y * Math.sin(phi);
					im += y * Math.cos(phi) - x * Math.sin(phi);
				}
				re /= N;
				im /= N;

				let freq = k > N / 2 ? k - N : k;
				C.push({re,im,freq,amp: Math.hypot(re,im),phase: Math.atan2(im,re)});
			}
			return C;
		}

		gapToleranceSlider.addEventListener('input',(e) => {
			gapToleranceLabel.textContent = `${e.target.value}px`;
		});

		fftVectorSlider.addEventListener('input',(e) => {
			fftVectorLabel.textContent = `${e.target.value}%`;
			pathData.forEach(pd => {pd.animationState.drawnPath = [];});
		});

		function startFftAnimation() {
			if(fftAnimationId) cancelAnimationFrame(fftAnimationId);
			if(pathData.length === 0) return;

			pathData.forEach(pd => {
				pd.animationState.time = 0;
				pd.animationState.drawnPath = [];
			});
			animateFft();
		}

		function animateFft() {
			const ctx = contexts.fft;
			clearCanvas(ctx);

			pathData.forEach((currentData,index) => {
				const {fourierCoefficients,animationState} = currentData;
				if(fourierCoefficients.length === 0) return;

				const N = fourierCoefficients.length;
				const coeffMap = new Map();
				for(const c of fourierCoefficients) {
					coeffMap.set(c.freq,c);
				}

				const sortedCoefficients = [];
				if(coeffMap.has(0)) sortedCoefficients.push(coeffMap.get(0));
				for(let k = 1;k <= N / 2;k++) {
					if(coeffMap.has(k)) sortedCoefficients.push(coeffMap.get(k));
					if(coeffMap.has(-k)) sortedCoefficients.push(coeffMap.get(-k));
				}

				const numVectorsToShow = Math.ceil(sortedCoefficients.length * (fftVectorSlider.value / 100));
				const coefficientsToDraw = sortedCoefficients.slice(0,numVectorsToShow);

				let x = canvases.fft.width / 2;
				let y = canvases.fft.height / 2;

				ctx.save();
				for(const Ck of coefficientsToDraw) {
					const prevX = x,prevY = y;
					const {amp,phase,freq} = Ck;
					const rotation = 2 * Math.PI * freq * animationState.time;
					x += amp * Math.cos(rotation + phase);
					y += amp * Math.sin(rotation + phase);

					if(freq === 0) continue;

					ctx.beginPath();
					ctx.strokeStyle = '#e2e8f0';
					ctx.lineWidth = 1;
					ctx.arc(prevX,prevY,amp,0,2 * Math.PI);
					ctx.stroke();

					ctx.beginPath();
					ctx.strokeStyle = '#cbd5e1';
					ctx.lineWidth = 1.5;
					ctx.moveTo(prevX,prevY);
					ctx.lineTo(x,y);
					ctx.stroke();
				}

				ctx.beginPath();
				ctx.fillStyle = PATH_COLORS[index % PATH_COLORS.length];
				ctx.arc(x,y,4,0,2 * Math.PI);
				ctx.fill();
				ctx.restore();

				animationState.drawnPath.unshift({x,y});
				if(animationState.drawnPath.length > N * 1.5) {
					animationState.drawnPath.pop();
				}

				ctx.beginPath();
				ctx.strokeStyle = PATH_COLORS[index % PATH_COLORS.length];
				ctx.lineWidth = 2.5;
				ctx.lineCap = "round";
				ctx.lineJoin = "round";
				for(let i = 0;i < animationState.drawnPath.length;i++) {
					const p = animationState.drawnPath[i];
					if(i === 0) ctx.moveTo(p.x,p.y);
					else ctx.lineTo(p.x,p.y);
				}
				ctx.stroke();

				const dt = 1 / (N * 0.75);
				animationState.time += dt;
				if(animationState.time > 1) animationState.time -= 1;
			});

			fftAnimationId = requestAnimationFrame(animateFft);
		}

		initializeApp();
	</script>
</body>

</html>