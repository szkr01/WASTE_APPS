<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Line Art Analyzer & Graph Visualizer</title>
    <meta name="description" content="Extract line art from images, binarize them, convert to a graph, and visualize structural points like junctions and endpoints.">
    <meta name="page:icon" content="fas fa-sitemap">
    <meta name="page:color" content="#38bdf8">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #loader-overlay {
            background-color: rgba(248, 250, 252, 0.85);
            backdrop-filter: blur(4px);
            transition: opacity 0.3s ease-in-out;
        }
        
        #loader-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border-left-color: #38bdf8;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            height: 4px;
            background: #e2e8f0;
            border-radius: 9999px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            margin-top: -6px;
            background-color: #38bdf8;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            border: none;
            transition: transform 0.2s ease;
        }
        input[type=range]:hover::-webkit-slider-thumb {
            transform: scale(1.1);
        }
        
        .canvas-container {
             background-color: #f1f5f9;
             border-radius: 0.5rem;
             aspect-ratio: 1 / 1;
             display: flex;
             align-items: center;
             justify-content: center;
             overflow: hidden;
        }

        .canvas-container canvas {
            max-width: 100%;
            max-height: 100%;
            height: auto;
            width: auto;
            background-color: white;
            border-radius: 0.25rem;
        }
    </style>
</head>

<body class="bg-slate-50 text-slate-700">

    <div id="loader-overlay" class="fixed inset-0 z-50 flex-col items-center justify-center hidden">
        <div class="spinner"></div>
        <p id="loader-status" class="mt-4 text-sm font-medium text-slate-600 tracking-wide"></p>
    </div>

    <div class="flex flex-col md:flex-row min-h-screen">
        <aside id="sidebar" class="w-full md:w-80 lg:w-96 bg-white border-r border-slate-200 p-6 lg:p-8 flex flex-col flex-shrink-0">
            <div class="flex-grow">
                <header class="mb-10">
                    <h1 class="text-2xl font-bold text-slate-800 flex items-center gap-3">
                        <i class="fas fa-sitemap text-sky-500"></i>
                        <span>AI Line Art Analyzer</span>
                    </h1>
                    <p class="text-sm text-slate-500 mt-1">Extract, analyze, and visualize line art structure.</p>
                </header>
                
                <div class="space-y-6">
                    <div>
                        <h2 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-3">1. Input & Preprocessing</h2>
                        <label for="image-upload" class="group cursor-pointer flex flex-col items-center justify-center w-full h-32 bg-slate-50 border-2 border-slate-200 border-dashed rounded-lg transition-colors hover:bg-sky-50 hover:border-sky-300">
                            <div class="flex flex-col items-center justify-center pt-5 pb-6 text-center px-2">
                                <i class="fas fa-upload text-2xl text-slate-400 group-hover:text-sky-500 transition-colors"></i>
                                <p id="upload-prompt" class="mt-2 text-sm text-slate-500 group-hover:text-sky-600 truncate max-w-full"><span class="font-semibold">Click to upload</span> or drag and drop</p>
                                <p class="text-xs text-slate-400">PNG, JPG, WEBP, etc.</p>
                            </div>
                            <input id="image-upload" type="file" class="hidden" accept="image/*" />
                        </label>
                        <div class="mt-4 space-y-4">
                             <div>
                                <label for="resize-select" class="block text-sm font-medium text-slate-700 mb-1.5">Resize (Longest Edge)</label>
                                <select id="resize-select" class="block w-full p-2.5 bg-slate-50 border border-slate-300 text-slate-900 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 transition">
                                    <option value="original">Original</option>
                                    <option value="1024">1024px</option>
                                    <option value="512" selected>512px</option>
                                    <option value="256">256px</option>
                                </select>
                            </div>
                            <div>
                                <label for="model-select" class="block text-sm font-medium text-slate-700 mb-1.5">AI Model</label>
                                <select id="model-select" class="block w-full p-2.5 bg-slate-50 border border-slate-300 text-slate-900 text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 transition">
                                    <option value="opensketch_style_512x512.onnx">OpenSketch</option>
                                    <option value="anime_style_512x512.onnx">Anime</option>
                                    <option value="contour_style_512x512.onnx">Contour</option>
                                </select>
                            </div>
                        </div>
                    </div>
                     <button id="process-button" class="w-full bg-sky-500 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 shadow-md transform hover:scale-105 hover:bg-sky-600 disabled:bg-slate-300 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none">
                        <i class="fas fa-magic-wand-sparkles mr-2"></i>Analyze Image
                    </button>
                    <fieldset id="analysis-controls" class="space-y-4" disabled>
                        <h2 class="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-3 pt-2 border-t">2. Real-time Analysis</h2>
                         <div>
                            <label for="threshold-slider" class="flex justify-between text-sm font-medium text-slate-700 mb-1.5">
                                <span>Binarization Threshold</span>
                                <span id="threshold-label" class="font-semibold text-sky-600">128</span>
                            </label>
                            <input id="threshold-slider" type="range" min="0" max="255" value="128">
                        </div>
                        <div>
                            <label for="gap-tolerance-slider" class="flex justify-between text-sm font-medium text-slate-700 mb-1.5">
                                <span>DFS Gap Tolerance</span>
                                <span id="gap-tolerance-label" class="font-semibold text-sky-600">1px</span>
                            </label>
                            <input id="gap-tolerance-slider" type="range" min="1" max="10" value="1">
                        </div>
                    </fieldset>
                </div>
            </div>

            <div class="mt-8">
                <p id="status-message" class="text-center text-slate-500 text-xs tracking-wide h-4"></p>
            </div>
        </aside>

        <main class="flex-1 p-6 lg:p-10 bg-slate-100/50">
            <div class="max-w-7xl mx-auto">
                <header class="mb-8">
                    <h1 class="text-3xl md:text-4xl font-bold text-slate-900">Analysis Pipeline</h1>
                    <p class="text-slate-500 mt-2 max-w-2xl">From original image to a simplified structural graph.</p>
                </header>

                <section id="visualizations" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 lg:gap-8">
                    <div class="bg-white p-4 sm:p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-sm font-semibold text-slate-800 mb-3">1. Original Image</h2>
                        <div class="canvas-container"><canvas id="canvas-original"></canvas></div>
                    </div>
                    <div class="bg-white p-4 sm:p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-sm font-semibold text-slate-800 mb-3">2. Extracted Line Art</h2>
                        <div class="canvas-container"><canvas id="canvas-lineart"></canvas></div>
                    </div>
                    <div class="bg-white p-4 sm:p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-sm font-semibold text-slate-800 mb-3">3. Binarized Image</h2>
                        <div class="canvas-container"><canvas id="canvas-binarized"></canvas></div>
                    </div>
                    <div class="bg-white p-4 sm:p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-sm font-semibold text-slate-800 mb-3">4. Connected Paths (DFS)</h2>
                        <div class="canvas-container"><canvas id="canvas-paths"></canvas></div>
                    </div>
                    <div class="bg-white p-4 sm:p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-sm font-semibold text-slate-800 mb-3">5. Simplified Graph</h2>
                        <div class="canvas-container"><canvas id="canvas-graph"></canvas></div>
                    </div>
                    <div class="bg-white p-4 sm:p-5 rounded-xl shadow-sm border border-slate-200">
                        <h2 class="text-sm font-semibold text-slate-800 mb-3">6. Graph Statistics</h2>
                        <div class="h-full flex flex-col justify-center">
                             <div id="graph-stats" class="text-sm text-slate-600 space-y-3 p-4 bg-slate-50 rounded-lg">
                                <div class="flex justify-between items-center"><span><i class="fas fa-circle-nodes mr-2 text-slate-400"></i>Total Nodes:</span><span class="font-bold text-slate-800 text-base" id="stats-nodes">0</span></div>
                                <div class="flex justify-between items-center"><span><i class="fas fa-code-commit fa-rotate-90 mr-2 text-slate-400"></i>Total Edges:</span><span class="font-bold text-slate-800 text-base" id="stats-edges">0</span></div>
                                <hr class="my-2">
                                <div class="flex justify-between items-center"><span><i class="fas fa-code-branch mr-2 text-rose-500"></i>Junctions:</span><span class="font-bold text-rose-500 text-base" id="stats-junctions">0</span></div>
                                <div class="flex justify-between items-center"><span><i class="fas fa-minus-circle mr-2 text-emerald-500"></i>Endpoints:</span><span class="font-bold text-emerald-500 text-base" id="stats-endpoints">0</span></div>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </main>
    </div>

<script>
const statusEl = document.getElementById('status-message');
const processButton = document.getElementById('process-button');
const imageUpload = document.getElementById('image-upload');
const uploadPrompt = document.getElementById('upload-prompt');
const modelSelect = document.getElementById('model-select');
const resizeSelect = document.getElementById('resize-select');
const analysisControls = document.getElementById('analysis-controls');
const thresholdSlider = document.getElementById('threshold-slider');
const thresholdLabel = document.getElementById('threshold-label');
const gapToleranceSlider = document.getElementById('gap-tolerance-slider');
const gapToleranceLabel = document.getElementById('gap-tolerance-label');
const graphStatsEl = {
    nodes: document.getElementById('stats-nodes'),
    edges: document.getElementById('stats-edges'),
    junctions: document.getElementById('stats-junctions'),
    endpoints: document.getElementById('stats-endpoints'),
};

const loader = {
    overlay: document.getElementById('loader-overlay'),
    status: document.getElementById('loader-status'),
    show(message) {
        this.status.textContent = message;
        this.overlay.classList.remove('hidden');
        this.overlay.classList.add('flex');
    },
    hide() {
        this.overlay.classList.add('hidden');
        this.overlay.classList.remove('flex');
    }
};

const canvases = {
    original: document.getElementById('canvas-original'),
    lineart: document.getElementById('canvas-lineart'),
    binarized: document.getElementById('canvas-binarized'),
    paths: document.getElementById('canvas-paths'),
    graph: document.getElementById('canvas-graph'),
};
const contexts = {
    original: canvases.original.getContext('2d'),
    lineart: canvases.lineart.getContext('2d'),
    binarized: canvases.binarized.getContext('2d', { willReadFrequently: true }),
    paths: canvases.paths.getContext('2d'),
    graph: canvases.graph.getContext('2d'),
};

let onnxSession = null;
let originalImage = null;
let grayscaleImageData = null;

const MODEL_BASE_URL = "https://raw.githubusercontent.com/Kazuhito00/Informative-Drawings-ONNX-Sample/main/model/";
const MODEL_INPUT_SIZE = 512;
const PATH_COLORS = ['#38bdf8', '#f43f5e', '#10b981', '#f97316', '#8b5cf6', '#ec4899', '#65a30d', '#d97706', '#0891b2'];

function updateStatus(message, isError = false) {
    if (statusEl) {
        statusEl.textContent = message;
        statusEl.style.color = isError ? '#ef4444' : '#6b7280';
    }
}

function clearCanvas(ctx) {
    if (!ctx) return;
    const { width, height } = ctx.canvas;
    ctx.clearRect(0, 0, width, height);
}

function clearAllOutputCanvases() {
    Object.keys(contexts).forEach((key) => {
        if (key !== 'original') clearCanvas(contexts[key]);
    });
    updateGraphStats(); 
}

async function loadOnnxModel() {
    const modelName = modelSelect.value;
    const modelUrl = MODEL_BASE_URL + modelName;
    try {
        onnxSession = await ort.InferenceSession.create(modelUrl, { executionProviders: ['webgl', 'cpu'] });
    } catch (error) {
        console.error(`Failed to load model ${modelName}:`, error);
        onnxSession = null;
        throw error;
    }
}

async function initializeApp() {
    updateStatus('Initializing application...');
    loader.show('Loading initial AI model...');
    try {
        await loadOnnxModel();
        updateStatus('Ready. Please upload an image.');
        processButton.disabled = true;
        analysisControls.disabled = true;
    } catch (error) {
        updateStatus('Error initializing AI. Please reload.', true);
        [modelSelect, imageUpload, processButton, resizeSelect].forEach(el => el.disabled = true);
        analysisControls.disabled = true;
    } finally {
        loader.hide();
    }
}

imageUpload.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;

    uploadPrompt.innerHTML = `<span class="font-semibold">${file.name}</span>`;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        originalImage = new Image();
        originalImage.onload = () => {
            canvases.original.width = originalImage.width;
            canvases.original.height = originalImage.height;
            contexts.original.drawImage(originalImage, 0, 0);
            
            processButton.disabled = false;
            analysisControls.disabled = true;
            grayscaleImageData = null;
            updateStatus('Image loaded. Ready to analyze.');
            clearAllOutputCanvases();
        };
        originalImage.src = e.target.result;
    };
    reader.readAsDataURL(file);
});

async function runRealtimeAnalysis() {
    if (!grayscaleImageData) return;
    
    updateStatus('Analyzing...');
    await binarizeImage();

    await Promise.all([
        (async () => {
            const paths = await extractPathsWithDFS();
            drawPaths(paths);
        })(),
        (async () => {
            const binarizedImageData = contexts.binarized.getImageData(0, 0, canvases.binarized.width, canvases.binarized.height);
            const graph = buildAndSimplifyGraph(binarizedImageData);
            drawSimplifiedGraph(graph, canvases.binarized);
            updateGraphStats(graph);
        })()
    ]);
    
    updateStatus('Analysis complete.');
}

thresholdSlider.addEventListener('input', (e) => {
    thresholdLabel.textContent = e.target.value;
    runRealtimeAnalysis();
});

gapToleranceSlider.addEventListener('input', (e) => {
    gapToleranceLabel.textContent = `${e.target.value}px`;
    (async () => {
        updateStatus('Updating DFS paths...');
        const paths = await extractPathsWithDFS();
        drawPaths(paths);
        updateStatus('Analysis complete.');
    })();
});

modelSelect.addEventListener('change', async () => {
    loader.show(`Loading new model: ${modelSelect.options[modelSelect.selectedIndex].text}...`);
    try {
        await loadOnnxModel();
        updateStatus('New model loaded.');
        if (originalImage) {
            processButton.disabled = false;
        }
    } catch (error) {
        updateStatus('Failed to load selected model.', true);
    } finally {
        loader.hide();
    }
});

processButton.addEventListener('click', async () => {
    if (!originalImage || !onnxSession) {
        updateStatus('Please upload an image first.', true);
        return;
    }

    processButton.disabled = true;
    analysisControls.disabled = true;
    clearAllOutputCanvases();
    
    loader.show('Preprocessing and extracting line art...');
    try {
        resizeSourceImage();
        
        const resizedCanvas = document.createElement('canvas');
        resizedCanvas.width = canvases.lineart.width;
        resizedCanvas.height = canvases.lineart.height;
        resizedCanvas.getContext('2d').drawImage(originalImage, 0, 0, resizedCanvas.width, resizedCanvas.height);
        
        await runInference(resizedCanvas);
        analysisControls.disabled = false;
        await runRealtimeAnalysis();
    } catch (error) {
        console.error('Processing failed:', error);
        updateStatus(`An error occurred. Check console.`, true);
    } finally {
        loader.hide();
        processButton.disabled = false;
    }
});

function resizeSourceImage() {
    const resizeValue = resizeSelect.value;
    const targetSize = resizeValue === 'original' 
        ? Math.max(originalImage.width, originalImage.height) 
        : parseInt(resizeValue, 10);

    const aspectRatio = originalImage.width / originalImage.height;
    let newWidth, newHeight;
    if (originalImage.width > originalImage.height) {
        newWidth = targetSize;
        newHeight = targetSize / aspectRatio;
    } else {
        newHeight = targetSize;
        newWidth = targetSize * aspectRatio;
    }
    newWidth = Math.round(newWidth);
    newHeight = Math.round(newHeight);

    for (const key in canvases) {
        if (key !== 'original') {
            canvases[key].width = newWidth;
            canvases[key].height = newHeight;
        }
    }
}

async function runInference(sourceCanvas) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = MODEL_INPUT_SIZE;
    tempCanvas.height = MODEL_INPUT_SIZE;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(sourceCanvas, 0, 0, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE);
    
    const imageData = tempCtx.getImageData(0, 0, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE);
    const { data } = imageData;
    const float32Data = new Float32Array(3 * MODEL_INPUT_SIZE * MODEL_INPUT_SIZE);

    for (let i = 0; i < MODEL_INPUT_SIZE * MODEL_INPUT_SIZE; i++) {
        float32Data[i] = data[i * 4];
        float32Data[i + MODEL_INPUT_SIZE * MODEL_INPUT_SIZE] = data[i * 4 + 1];
        float32Data[i + 2 * MODEL_INPUT_SIZE * MODEL_INPUT_SIZE] = data[i * 4 + 2];
    }
    
    const inputName = onnxSession.inputNames[0];
    const inputTensor = new ort.Tensor('float32', float32Data, [1, 3, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE]);
    const feeds = { [inputName]: inputTensor };
    
    const results = await onnxSession.run(feeds);
    const outputName = onnxSession.outputNames[0];
    const outputData = results[outputName].data;

    const outputImageData = new ImageData(MODEL_INPUT_SIZE, MODEL_INPUT_SIZE);
    for (let i = 0; i < outputData.length; i++) {
        const value = Math.max(0, Math.min(255, outputData[i] * 255));
        outputImageData.data[i * 4] = value;
        outputImageData.data[i * 4 + 1] = value;
        outputImageData.data[i * 4 + 2] = value;
        outputImageData.data[i * 4 + 3] = 255;
    }

    const lineartTempCanvas = document.createElement('canvas');
    lineartTempCanvas.width = MODEL_INPUT_SIZE;
    lineartTempCanvas.height = MODEL_INPUT_SIZE;
    lineartTempCanvas.getContext('2d').putImageData(outputImageData, 0, 0);

    const targetCtx = contexts.lineart;
    clearCanvas(targetCtx);
    targetCtx.drawImage(lineartTempCanvas, 0, 0, targetCtx.canvas.width, targetCtx.canvas.height);
    grayscaleImageData = targetCtx.getImageData(0, 0, targetCtx.canvas.width, targetCtx.canvas.height);
}

async function binarizeImage() {
    if (!grayscaleImageData) return;
    const threshold = parseInt(thresholdSlider.value, 10);
    const { width, height } = grayscaleImageData;
    const newData = new Uint8ClampedArray(grayscaleImageData.data);

    for (let i = 0; i < newData.length; i += 4) {
        const value = newData[i] < threshold ? 0 : 255;
        newData[i] = newData[i + 1] = newData[i + 2] = value;
    }
    
    const newImageData = new ImageData(newData, width, height);
    clearCanvas(contexts.binarized);
    contexts.binarized.putImageData(newImageData, 0, 0);
}

async function extractPathsWithDFS() {
    const ctx = contexts.binarized;
    const { width, height } = ctx.canvas;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const visited = new Uint8Array(width * height);
    const allPaths = [];
    const minPathLength = 10;
    const gap = parseInt(gapToleranceSlider.value, 10);

    const isBlack = (x, y) => {
        if (x < 0 || x >= width || y < 0 || y >= height) return false;
        const index = y * width + x;
        return data[index * 4] === 0 && !visited[index];
    };

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (isBlack(x, y)) {
                const currentPath = [];
                const stack = [[x, y]];
                visited[y * width + x] = 1;

                while (stack.length > 0) {
                    const [cx, cy] = stack.pop();
                    currentPath.push({ x: cx, y: cy });

                    for (let dy = -gap; dy <= gap; dy++) {
                        for (let dx = -gap; dx <= gap; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = cx + dx;
                            const ny = cy + dy;
                            if (isBlack(nx, ny)) {
                                visited[ny * width + nx] = 1;
                                stack.push([nx, ny]);
                            }
                        }
                    }
                }

                if (currentPath.length > minPathLength) {
                    allPaths.push(currentPath);
                }
            }
        }
    }
    allPaths.sort((a, b) => b.length - a.length);
    return allPaths;
}

function drawPaths(paths) {
    const ctx = contexts.paths;
    clearCanvas(ctx);
    ctx.fillStyle = 'white';
    ctx.fillRect(0,0, ctx.canvas.width, ctx.canvas.height);

    paths.forEach((path, index) => {
        ctx.fillStyle = PATH_COLORS[index % PATH_COLORS.length];
        path.forEach(point => {
            ctx.fillRect(point.x, point.y, 1, 1);
        });
    });
}

function buildAndSimplifyGraph(imageData) {
    const { width, height, data } = imageData;
    const adj = new Map();
    const getId = (x, y) => y * width + x;
    const isBlack = (x, y) => {
        if (x < 0 || x >= width || y < 0 || y >= height) return false;
        return data[getId(x, y) * 4] === 0;
    };

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (isBlack(x, y)) {
                const id = getId(x, y);
                const neighbors = [];
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        if (isBlack(x + dx, y + dy)) {
                            neighbors.push(getId(x + dx, y + dy));
                        }
                    }
                }
                if (neighbors.length > 0) {
                     adj.set(id, { x, y, neighbors });
                }
            }
        }
    }

    const keyNodes = new Map();
    for (const [id, node] of adj.entries()) {
        if (node.neighbors.length !== 2) {
            keyNodes.set(id, { ...node, id, type: node.neighbors.length <= 1 ? 'endpoint' : 'junction' });
        }
    }

    const edges = [];
    const visitedPaths = new Set();
    for (const [startId, startNode] of keyNodes.entries()) {
        for (const neighborId of startNode.neighbors) {
            const path = [{ x: startNode.x, y: startNode.y }];
            let prevId = startId;
            let currentId = neighborId;
            while (adj.has(currentId) && !keyNodes.has(currentId)) {
                const currentNode = adj.get(currentId);
                path.push({ x: currentNode.x, y: currentNode.y });
                const nextNeighbor = currentNode.neighbors.find(n => n !== prevId);
                if (!nextNeighbor) break;
                prevId = currentId;
                currentId = nextNeighbor;
            }
            if (keyNodes.has(currentId)) {
                const edgeKey = [startId, currentId].sort().join('-');
                if (!visitedPaths.has(edgeKey)) {
                    const endNode = keyNodes.get(currentId);
                    path.push({ x: endNode.x, y: endNode.y });
                    edges.push({ from: startNode, to: endNode, path });
                    visitedPaths.add(edgeKey);
                }
            }
        }
    }
    return { nodes: Array.from(keyNodes.values()), edges };
}

function drawSimplifiedGraph(graph, binarizedCanvas) {
    const ctx = contexts.graph;
    clearCanvas(ctx);

    ctx.globalAlpha = 0.15;
    ctx.drawImage(binarizedCanvas, 0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.globalAlpha = 1.0;

    ctx.lineWidth = 2.5;
    graph.edges.forEach(edge => {
        ctx.strokeStyle = '#38bdf8';
        ctx.beginPath();
        ctx.moveTo(edge.path[0].x, edge.path[0].y);
        for (let i = 1; i < edge.path.length; i++) {
            ctx.lineTo(edge.path[i].x, edge.path[i].y);
        }
        ctx.stroke();
    });

    graph.nodes.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 4.5, 0, 2 * Math.PI);
        if (node.type === 'junction') {
            ctx.fillStyle = '#f43f5e';
        } else {
            ctx.fillStyle = '#10b981';
        }
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1.5;
        ctx.stroke();
    });
}

function updateGraphStats(graph = { nodes: [], edges: [] }) {
    const junctions = graph.nodes.filter(n => n.type === 'junction').length;
    const endpoints = graph.nodes.filter(n => n.type === 'endpoint').length;
    graphStatsEl.nodes.textContent = graph.nodes.length;
    graphStatsEl.edges.textContent = graph.edges.length;
    graphStatsEl.junctions.textContent = junctions;
    graphStatsEl.endpoints.textContent = endpoints;
}

initializeApp();
</script>
</body>
</html>