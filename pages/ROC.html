<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title>ROC演習ジェネレータ</title>
	<meta name="description"
		content="ROC曲線とAUCをインタラクティブに学習・演習するためのジェネレータ。ランダムなデータセットの生成や、データの自由な編集を通じて、手計算の検証や概念の理解を深めることができます。">
	<meta name="page:icon" content="fas fa-edit">
	<meta name="page:color" content="#38bdf8">

	<script src="https://cdn.tailwindcss.com"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

	<style>
		@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap');

		html {
			scroll-behavior: smooth;
		}

		body {
			font-family: 'Noto Sans JP', sans-serif;
			background-color: #f8fafc;
			/* Tailwind's gray-50 */
		}

		.main-container {
			max-width: 1400px;
			margin: auto;
		}

		.card {
			background-color: white;
			border-radius: 0.75rem;
			border: 1px solid #e5e7eb;
			box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05), 0 2px 4px -2px rgb(0 0 0 / 0.05);
			transition: all 0.3s ease-in-out;
		}

		.card-header {
			border-bottom: 1px solid #e5e7eb;
			/* gray-200 */
			padding: 1rem 1.5rem;
		}

		.card-content {
			padding: 1rem;
		}

		@media (min-width: 640px) {
			.card-content {
				padding: 1.5rem;
			}
		}

		.results-section {
			opacity: 0;
			transform: translateY(20px);
			transition: opacity 0.5s ease-out, transform 0.5s ease-out;
			max-height: 0;
			overflow: hidden;
		}

		.results-section.visible {
			opacity: 1;
			transform: translateY(0);
			max-height: 2000px;
			transition: opacity 0.5s ease-out, transform 0.5s ease-out, max-height 0.8s ease-in-out;
		}

		#roc-canvas {
			border: 1px solid #e5e7eb;
			border-radius: 0.5rem;
			background-image:
				linear-gradient(to right, #f1f5f9 1px, transparent 1px),
				linear-gradient(to bottom, #f1f5f9 1px, transparent 1px);
			background-size: 20px 20px;
			width: 100%;
			height: auto;
			aspect-ratio: 1 / 1;
		}

		.tooltip {
			position: fixed;
			background: rgba(0, 0, 0, 0.85);
			color: white;
			padding: 6px 12px;
			border-radius: 6px;
			font-size: 0.8rem;
			pointer-events: none;
			opacity: 0;
			transition: opacity 0.2s;
			white-space: pre;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
			z-index: 50;
		}

		input[type="number"]::-webkit-inner-spin-button,
		input[type="number"]::-webkit-outer-spin-button {
			-webkit-appearance: none;
			margin: 0;
		}

		input[type="number"] {
			-moz-appearance: textfield;
		}

		.editable-table-input {
			@apply w-full p-2 border border-gray-200 rounded-md shadow-sm focus:ring-2 focus:ring-sky-500 focus:border-sky-500 hover:border-gray-400 transition duration-200;
		}
	</style>
</head>

<body class="antialiased text-gray-800">

	<div class="main-container p-4 sm:p-6 lg:p-8">
		<header class="text-center mb-10">
			<h1 class="text-3xl sm:text-4xl font-bold text-gray-900">ROC演習ジェネレータ</h1>
			<p class="mt-2 text-md sm:text-lg text-gray-600">データを生成・編集し、ROC曲線とAUCをインタラクティブに確認できます。</p>
		</header>

		<div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">

			<div class="flex flex-col gap-8">
				<div class="card">
					<div class="card-header">
						<h2 class="text-xl font-bold text-gray-800 flex items-center">
							<i class="fas fa-cogs text-sky-500 mr-3"></i>
							ジェネレータ設定
						</h2>
					</div>
					<div class="card-content">
						<div class="flex flex-col sm:flex-row items-center gap-4">
							<div class="w-full sm:w-1/3">
								<label for="data-count"
									class="block text-sm font-medium text-gray-700 mb-1">データ数</label>
								<input type="number" id="data-count" value="8" min="4" max="30"
									class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
							</div>
							<div class="w-full sm:w-2/3 pt-0 sm:pt-6">
								<button id="generate-button"
									class="w-full bg-gray-700 hover:bg-gray-800 text-white font-bold py-2.5 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center">
									<i class="fas fa-sync-alt mr-2"></i> 新しいデータを生成
								</button>
							</div>
						</div>
					</div>
				</div>

				<div class="card">
					<div class="card-header flex justify-between items-center">
						<h2 class="text-xl font-bold text-gray-800 flex items-center">
							<i class="fas fa-edit text-sky-500 mr-3"></i>
							評価用データ (編集可能)
						</h2>
						<button id="solve-button"
							class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 flex items-center justify-center text-sm disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none">
							<i class="fas fa-calculator mr-2"></i> 解を計算
						</button>
					</div>
					<div class="card-content">
						<div class="overflow-x-auto">
							<table class="w-full text-left">
								<thead class="bg-gray-50 border-b-2 border-gray-200">
									<tr>
										<th class="p-3 text-sm font-semibold tracking-wide w-1/6">Index</th>
										<th class="p-3 text-sm font-semibold tracking-wide">Prediction score</th>
										<th class="p-3 text-sm font-semibold tracking-wide">True label</th>
									</tr>
								</thead>
								<tbody id="data-table-body" class="divide-y divide-gray-100">
								</tbody>
							</table>
						</div>
					</div>
				</div>
			</div>

			<div id="solution-column" class="flex flex-col gap-8">
				<div id="results-container" class="results-section">
					<div class="card">
						<div class="card-header">
							<h2 class="text-xl font-bold text-gray-800 flex items-center">
								<i class="fas fa-chart-area text-sky-500 mr-3"></i>
								ROC 曲線
							</h2>
						</div>
						<div class="card-content relative">
							<canvas id="roc-canvas"></canvas>
							<div id="canvas-tooltip" class="tooltip"></div>
						</div>
					</div>
				</div>

				<div id="auc-container" class="results-section">
					<div class="card">
						<div class="card-header">
							<h2 class="text-xl font-bold text-gray-800 flex items-center">
								<i class="fas fa-ruler-combined text-sky-500 mr-3"></i>
								AUC (曲線下面積)
							</h2>
						</div>
						<div class="card-content text-center">
							<p class="text-gray-600 text-lg">計算されたAUC値:</p>
							<p id="auc-value" class="text-4xl sm:text-5xl font-bold text-sky-600 my-4"></p>
						</div>
					</div>
				</div>

				<div id="steps-container" class="results-section">
					<div class="card">
						<div class="card-header">
							<h2 class="text-xl font-bold text-gray-800 flex items-center">
								<i class="fas fa-shoe-prints text-sky-500 mr-3"></i>
								計算ステップ
							</h2>
						</div>
						<div class="card-content">
							<div class="overflow-x-auto max-h-96">
								<table class="w-full text-sm text-left">
									<thead class="bg-gray-50 sticky top-0 z-10">
										<tr>
											<th class="p-2">Score</th>
											<th class="p-2">Label</th>
											<th class="p-2">TP</th>
											<th class="p-2">FP</th>
											<th class="p-2">TPR</th>
											<th class="p-2">FPR</th>
										</tr>
									</thead>
									<tbody id="steps-table-body" class="divide-y divide-gray-100">
									</tbody>
								</table>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>

	<script>
		document.addEventListener('DOMContentLoaded',() => {
			let currentData = [];
			let lastRocPoints = null;

			const dataCountInput = document.getElementById('data-count');
			const generateButton = document.getElementById('generate-button');
			const solveButton = document.getElementById('solve-button');
			const dataTableBody = document.getElementById('data-table-body');
			const stepsTableBody = document.getElementById('steps-table-body');
			const solutionColumn = document.getElementById('solution-column');

			const resultsContainer = document.getElementById('results-container');
			const aucContainer = document.getElementById('auc-container');
			const stepsContainer = document.getElementById('steps-container');
			const aucValueEl = document.getElementById('auc-value');
			const canvas = document.getElementById('roc-canvas');
			const tooltip = document.getElementById('canvas-tooltip');
			const ctx = canvas.getContext('2d');

			const debounce = (func,wait) => {
				let timeout;
				return function executedFunction(...args) {
					const later = () => {
						clearTimeout(timeout);
						func(...args);
					};
					clearTimeout(timeout);
					timeout = setTimeout(later,wait);
				};
			};

			const generateNewData = () => {
				const count = parseInt(dataCountInput.value,10);
				if(isNaN(count) || count < 4 || count > 30) {
					alert("データ数は4から30の間で指定してください。");
					return;
				}

				currentData = [];
				let positiveCount = 0;
				let negativeCount = 0;

				const usedScores = new Set();
				for(let i = 0;i < count;i++) {
					let score;
					do {
						score = Math.round((Math.random() * 20 - 10) * 2) / 2;
					} while(usedScores.has(score));
					usedScores.add(score);

					let label = Math.random() > 0.5 ? 1 : -1;
					currentData.push({index: i + 1,score,label});
					if(label === 1) positiveCount++; else negativeCount++;
				}

				if(positiveCount < 2) {
					for(let i = 0;i < currentData.length && positiveCount < 2;i++) {
						if(currentData[i].label === -1) {
							currentData[i].label = 1;
							positiveCount++;
							negativeCount--;
						}
					}
				}
				if(negativeCount < 2) {
					for(let i = 0;i < currentData.length && negativeCount < 2;i++) {
						if(currentData[i].label === 1) {
							currentData[i].label = -1;
							negativeCount++;
							positiveCount--;
						}
					}
				}

				renderDataTable();
				resetUI();
			};

			const handleDataEdit = (e) => {
				const input = e.target;
				const index = parseInt(input.dataset.index,10);
				const field = input.dataset.field;
				const dataItem = currentData.find(d => d.index === index);

				if(!dataItem) return;

				if(field === 'score') {
					const value = parseFloat(input.value);
					if(!isNaN(value)) {
						dataItem.score = value;
					} else {
						input.value = dataItem.score.toFixed(1);
					}
				} else if(field === 'label') {
					let value = input.value.trim();
					let parsedValue = NaN;

					if(value === '1' || value === '+1') {
						parsedValue = 1;
						input.value = '+1';
					} else if(value === '-1') {
						parsedValue = -1;
						input.value = '-1';
					}

					if(!isNaN(parsedValue)) {
						dataItem.label = parsedValue;
						updateLabelColor(input,parsedValue);
					} else {
						input.value = dataItem.label === 1 ? '+1' : '-1';
						updateLabelColor(input,dataItem.label);
						alert("ラベルは '+1' または '-1' で入力してください。");
					}
				}
				resetUI();
			};

			const updateLabelColor = (inputElement,value) => {
				inputElement.classList.remove('text-green-600','text-red-600','border-red-500');
				if(value === 1) {
					inputElement.classList.add('text-green-600');
				} else if(value === -1) {
					inputElement.classList.add('text-red-600');
				} else {
					inputElement.classList.add('border-red-500');
				}
			}

			const renderDataTable = () => {
				dataTableBody.innerHTML = '';
				currentData.forEach(item => {
					const row = document.createElement('tr');
					row.className = 'bg-white';

					row.innerHTML = `
                <td class="p-3 text-sm text-gray-700">${item.index}</td>
                <td class="p-1"><input type="number" step="0.1" value="${item.score.toFixed(1)}" data-index="${item.index}" data-field="score" class="editable-table-input"></td>
                <td class="p-1"><input type="text" value="${item.label === 1 ? '+1' : '-1'}" data-index="${item.index}" data-field="label" class="editable-table-input text-center font-medium"></td>
            `;

					const scoreInput = row.querySelector('input[data-field="score"]');
					const labelInput = row.querySelector('input[data-field="label"]');

					updateLabelColor(labelInput,item.label);

					scoreInput.addEventListener('change',handleDataEdit);
					labelInput.addEventListener('change',handleDataEdit);

					dataTableBody.appendChild(row);
				});
			};

			const resetUI = () => {
				resultsContainer.classList.remove('visible');
				aucContainer.classList.remove('visible');
				stepsContainer.classList.remove('visible');

				solveButton.disabled = false;
				solveButton.innerHTML = `<i class="fas fa-calculator mr-2"></i> 解を計算`;
				solveButton.classList.remove('bg-green-500','cursor-not-allowed');
				solveButton.classList.add('bg-sky-500','hover:bg-sky-600');

				aucValueEl.textContent = '';
				stepsTableBody.innerHTML = '';
				lastRocPoints = null;
				clearCanvas();
			};

			const clearCanvas = () => {
				ctx.clearRect(0,0,canvas.width,canvas.height);
			};

			const handleSolve = () => {
				if(currentData.length === 0) return;

				const P = currentData.filter(d => d.label === 1).length;
				const N = currentData.filter(d => d.label === -1).length;

				if(P === 0 || N === 0) {
					alert("ROC曲線を計算するには、正例と負例の両方が必要です。");
					return;
				}

				const sortedData = [...currentData].sort((a,b) => b.score - a.score);

				let tp = 0;
				let fp = 0;
				const rocPoints = [{tpr: 0,fpr: 0,score: Infinity}];
				const calculationSteps = [{score: "Thresh > max",label: "-",tp: 0,fp: 0,tpr: "0.00",fpr: "0.00"}];

				for(let i = 0;i < sortedData.length;i++) {
					const point = sortedData[i];
					if(point.label === 1) tp++; else fp++;

					if(i < sortedData.length - 1 && sortedData[i + 1].score === point.score) {
						continue;
					}

					const tpr = P > 0 ? tp / P : 0;
					const fpr = N > 0 ? fp / N : 0;
					rocPoints.push({tpr,fpr,score: point.score});
					calculationSteps.push({score: point.score.toFixed(1),label: point.label > 0 ? '+1' : '−1',tp,fp,tpr: tpr.toFixed(2),fpr: fpr.toFixed(2)});
				}

				displayCalculationSteps(calculationSteps);
				const auc = calculateAUC(rocPoints);
				displayResults(auc);

				lastRocPoints = rocPoints;
				drawRocCurve();

				solveButton.innerHTML = `<i class="fas fa-check-circle mr-2"></i> 計算完了`;
				solveButton.disabled = true;
				solveButton.classList.remove('hover:bg-sky-600');
				solveButton.classList.add('bg-green-500','cursor-not-allowed');

				if(window.innerWidth < 1024) {
					solutionColumn.scrollIntoView({behavior: 'smooth'});
				}
			};

			function displayCalculationSteps(steps) {
				stepsTableBody.innerHTML = '';
				steps.forEach(step => {
					const row = document.createElement('tr');
					row.className = 'bg-white';
					row.innerHTML = `
                <td class="p-2">${step.score}</td>
                <td class="p-2 font-medium ${step.label === '+1' ? 'text-green-600' : step.label === '−1' ? 'text-red-600' : ''}">${step.label}</td>
                <td class="p-2">${step.tp}</td>
                <td class="p-2">${step.fp}</td>
                <td class="p-2">${step.tpr}</td>
                <td class="p-2">${step.fpr}</td>
            `;
					stepsTableBody.appendChild(row);
				});
			}

			function calculateAUC(points) {
				let area = 0;
				for(let i = 1;i < points.length;i++) {
					const p1 = points[i - 1];
					const p2 = points[i];
					const width = p2.fpr - p1.fpr;
					const height = (p1.tpr + p2.tpr) / 2;
					area += width * height;
				}
				return area;
			}

			function displayResults(auc) {
				aucValueEl.textContent = auc.toFixed(4);
				setTimeout(() => resultsContainer.classList.add('visible'),0);
				setTimeout(() => aucContainer.classList.add('visible'),200);
				setTimeout(() => stepsContainer.classList.add('visible'),400);
			}

			function drawRocCurve() {
				if(!lastRocPoints) return;
				const rocPoints = lastRocPoints;

				const dpr = window.devicePixelRatio || 1;
				const rect = canvas.getBoundingClientRect();
				canvas.width = rect.width * dpr;
				canvas.height = rect.height * dpr;
				ctx.scale(dpr,dpr);

				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const padding = width < 400 ? 40 : 50;

				const toCanvasX = (fpr) => padding + fpr * (width - padding * 2);
				const toCanvasY = (tpr) => (height - padding) - tpr * (height - padding * 2);

				ctx.clearRect(0,0,width,height);
				const fontSize = width < 400 ? 10 : 12;
				ctx.font = `${fontSize}px "Noto Sans JP", sans-serif`;
				ctx.fillStyle = '#6b7280';
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';

				ctx.fillText('FPR',width / 2,height - (padding / 2.5));
				ctx.save();
				ctx.translate(padding / 2.5,height / 2);
				ctx.rotate(-Math.PI / 2);
				ctx.fillText('TPR',0,0);
				ctx.restore();

				for(let i = 0;i <= 5;i++) {
					const val = i * 0.2;
					ctx.fillText(val.toFixed(1),padding - (padding / 2),toCanvasY(val));
					ctx.fillText(val.toFixed(1),toCanvasX(val),height - padding + (padding / 2));
				}

				ctx.strokeStyle = '#9ca3af';
				ctx.lineWidth = 1;
				ctx.beginPath();
				ctx.moveTo(padding,padding);
				ctx.lineTo(padding,height - padding);
				ctx.lineTo(width - padding,height - padding);
				ctx.stroke();

				ctx.beginPath();
				ctx.setLineDash([4,4]);
				ctx.moveTo(toCanvasX(0),toCanvasY(0));
				ctx.lineTo(toCanvasX(1),toCanvasY(1));
				ctx.strokeStyle = '#fb923c';
				ctx.lineWidth = 1.5;
				ctx.stroke();
				ctx.setLineDash([]);

				ctx.beginPath();
				ctx.moveTo(toCanvasX(rocPoints[0].fpr),toCanvasY(rocPoints[0].tpr));
				rocPoints.forEach(p => ctx.lineTo(toCanvasX(p.fpr),toCanvasY(p.tpr)));

				ctx.lineTo(toCanvasX(1),toCanvasY(0));
				ctx.closePath();
				ctx.fillStyle = 'rgba(56, 189, 248, 0.2)';
				ctx.fill();

				ctx.beginPath();
				rocPoints.forEach((p,i) => {
					const x = toCanvasX(p.fpr);
					const y = toCanvasY(p.tpr);
					if(i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
				});
				ctx.strokeStyle = '#0284c7';
				ctx.lineWidth = 3;
				ctx.lineJoin = 'round';
				ctx.lineCap = 'round';
				ctx.stroke();

				const canvasPoints = rocPoints.map(p => ({
					...p,
					cx: toCanvasX(p.fpr),
					cy: toCanvasY(p.tpr),
				}));

				canvasPoints.forEach(p => {
					ctx.beginPath();
					ctx.arc(p.cx,p.cy,5,0,2 * Math.PI);
					ctx.fillStyle = '#fff';
					ctx.fill();
					ctx.strokeStyle = '#0ea5e9';
					ctx.lineWidth = 2;
					ctx.stroke();
				});

				const tooltipHandler = (e) => {
					const rect = canvas.getBoundingClientRect();
					const mouseX = e.type.startsWith('touch') ? e.touches[0].clientX - rect.left : e.offsetX;
					const mouseY = e.type.startsWith('touch') ? e.touches[0].clientY - rect.top : e.offsetY;

					let foundPoint = null;
					let minDistance = Infinity;

					for(const p of canvasPoints) {
						const dist = Math.sqrt((mouseX - p.cx) ** 2 + (mouseY - p.cy) ** 2);
						if(dist < 12 && dist < minDistance) {
							foundPoint = p;
							minDistance = dist;
						}
					}

					if(foundPoint) {
						const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
						const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;

						tooltip.style.opacity = '1';
						tooltip.style.left = `${clientX + 10}px`;
						tooltip.style.top = `${clientY - 10}px`;
						tooltip.style.transform = 'translateY(-100%)';
						const scoreText = foundPoint.score === Infinity ? 'max' : foundPoint.score.toFixed(1);
						tooltip.innerHTML = `Threshold ≤ ${scoreText}\nTPR: ${foundPoint.tpr.toFixed(2)}\nFPR: ${foundPoint.fpr.toFixed(2)}`;
					} else {
						tooltip.style.opacity = '0';
					}
				};

				canvas.onmousemove = tooltipHandler;
				canvas.ontouchstart = tooltipHandler;
				canvas.ontouchmove = tooltipHandler;

				canvas.onmouseleave = () => {tooltip.style.opacity = '0';};
				canvas.ontouchend = () => {tooltip.style.opacity = '0';};
			}

			generateButton.addEventListener('click',generateNewData);
			solveButton.addEventListener('click',handleSolve);
			window.addEventListener('resize',debounce(drawRocCurve,200));

			generateNewData();
		});
	</script>

</body>

</html>